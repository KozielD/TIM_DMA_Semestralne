
C:\Users\G50\Atollic\TrueSTUDIO\ARM_workspace_7.0\en.stm32cubel1\STM32Cube_FW_L1_V1.6.0\Projects\STM32L152RE-Nucleo\Examples\TIM\TIM_DMA\TrueSTUDIO\STM32L152RE_NUCLEO\Debug\STM32L152RE_NUCLEO.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000013c  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000020c8  0800013c  0800013c  0001013c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000024  08002204  08002204  00012204  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08002228  08002228  00012228  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  0800222c  0800222c  0001222c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         000000ac  20000000  08002230  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          000016c4  200000ac  080022dc  000200ac  2**2
                  ALLOC
  7 ._user_heap_stack 00000600  20001770  080022dc  00021770  2**0
                  ALLOC
  8 .ARM.attributes 00000029  00000000  00000000  000200ac  2**0
                  CONTENTS, READONLY
  9 .debug_info   0000b0fe  00000000  00000000  000200d5  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00001cb1  00000000  00000000  0002b1d3  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005d2f  00000000  00000000  0002ce84  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 000007c8  00000000  00000000  00032bb8  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000ba0  00000000  00000000  00033380  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00004730  00000000  00000000  00033f20  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00002c54  00000000  00000000  00038650  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .comment      0000007e  00000000  00000000  0003b2a4  2**0
                  CONTENTS, READONLY
 17 .debug_frame  0000158c  00000000  00000000  0003b324  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0800013c <__do_global_dtors_aux>:
 800013c:	b510      	push	{r4, lr}
 800013e:	4c05      	ldr	r4, [pc, #20]	; (8000154 <__do_global_dtors_aux+0x18>)
 8000140:	7823      	ldrb	r3, [r4, #0]
 8000142:	b933      	cbnz	r3, 8000152 <__do_global_dtors_aux+0x16>
 8000144:	4b04      	ldr	r3, [pc, #16]	; (8000158 <__do_global_dtors_aux+0x1c>)
 8000146:	b113      	cbz	r3, 800014e <__do_global_dtors_aux+0x12>
 8000148:	4804      	ldr	r0, [pc, #16]	; (800015c <__do_global_dtors_aux+0x20>)
 800014a:	f3af 8000 	nop.w
 800014e:	2301      	movs	r3, #1
 8000150:	7023      	strb	r3, [r4, #0]
 8000152:	bd10      	pop	{r4, pc}
 8000154:	200000ac 	.word	0x200000ac
 8000158:	00000000 	.word	0x00000000
 800015c:	080021ec 	.word	0x080021ec

08000160 <frame_dummy>:
 8000160:	b508      	push	{r3, lr}
 8000162:	4b03      	ldr	r3, [pc, #12]	; (8000170 <frame_dummy+0x10>)
 8000164:	b11b      	cbz	r3, 800016e <frame_dummy+0xe>
 8000166:	4903      	ldr	r1, [pc, #12]	; (8000174 <frame_dummy+0x14>)
 8000168:	4803      	ldr	r0, [pc, #12]	; (8000178 <frame_dummy+0x18>)
 800016a:	f3af 8000 	nop.w
 800016e:	bd08      	pop	{r3, pc}
 8000170:	00000000 	.word	0x00000000
 8000174:	200000b0 	.word	0x200000b0
 8000178:	080021ec 	.word	0x080021ec

0800017c <BSP_LED_Init>:
  *          This parameter can be one of the following values:
  *     @arg LED2
  * @retval None
  */
void BSP_LED_Init(Led_TypeDef Led)
{
 800017c:	b5f0      	push	{r4, r5, r6, r7, lr}
  GPIO_InitTypeDef  gpioinitstruct;
  
  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);
 800017e:	4604      	mov	r4, r0
  *          This parameter can be one of the following values:
  *     @arg LED2
  * @retval None
  */
void BSP_LED_Init(Led_TypeDef Led)
{
 8000180:	b087      	sub	sp, #28
  GPIO_InitTypeDef  gpioinitstruct;
  
  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);
 8000182:	b948      	cbnz	r0, 8000198 <BSP_LED_Init+0x1c>
 8000184:	4b0f      	ldr	r3, [pc, #60]	; (80001c4 <BSP_LED_Init+0x48>)
 8000186:	69da      	ldr	r2, [r3, #28]
 8000188:	f042 0201 	orr.w	r2, r2, #1
 800018c:	61da      	str	r2, [r3, #28]
 800018e:	69db      	ldr	r3, [r3, #28]
 8000190:	f003 0301 	and.w	r3, r3, #1
 8000194:	9300      	str	r3, [sp, #0]
 8000196:	9b00      	ldr	r3, [sp, #0]
  gpioinitstruct.Pin    = LED_PIN[Led];
  gpioinitstruct.Mode   = GPIO_MODE_OUTPUT_PP;
  gpioinitstruct.Pull   = GPIO_NOPULL;
  gpioinitstruct.Speed  = GPIO_SPEED_FREQ_HIGH;
  
  HAL_GPIO_Init(LED_PORT[Led], &gpioinitstruct);
 8000198:	4d0b      	ldr	r5, [pc, #44]	; (80001c8 <BSP_LED_Init+0x4c>)
  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);

  /* Configure the GPIO_LED pin */
  gpioinitstruct.Pin    = LED_PIN[Led];
  gpioinitstruct.Mode   = GPIO_MODE_OUTPUT_PP;
 800019a:	2301      	movs	r3, #1
  
  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);

  /* Configure the GPIO_LED pin */
  gpioinitstruct.Pin    = LED_PIN[Led];
 800019c:	2620      	movs	r6, #32
  gpioinitstruct.Mode   = GPIO_MODE_OUTPUT_PP;
 800019e:	9302      	str	r3, [sp, #8]
  gpioinitstruct.Pull   = GPIO_NOPULL;
 80001a0:	2700      	movs	r7, #0
  gpioinitstruct.Speed  = GPIO_SPEED_FREQ_HIGH;
 80001a2:	2302      	movs	r3, #2
  
  HAL_GPIO_Init(LED_PORT[Led], &gpioinitstruct);
 80001a4:	a901      	add	r1, sp, #4
 80001a6:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]

  /* Configure the GPIO_LED pin */
  gpioinitstruct.Pin    = LED_PIN[Led];
  gpioinitstruct.Mode   = GPIO_MODE_OUTPUT_PP;
  gpioinitstruct.Pull   = GPIO_NOPULL;
  gpioinitstruct.Speed  = GPIO_SPEED_FREQ_HIGH;
 80001aa:	9304      	str	r3, [sp, #16]
  
  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);

  /* Configure the GPIO_LED pin */
  gpioinitstruct.Pin    = LED_PIN[Led];
 80001ac:	9601      	str	r6, [sp, #4]
  gpioinitstruct.Mode   = GPIO_MODE_OUTPUT_PP;
  gpioinitstruct.Pull   = GPIO_NOPULL;
 80001ae:	9703      	str	r7, [sp, #12]
  gpioinitstruct.Speed  = GPIO_SPEED_FREQ_HIGH;
  
  HAL_GPIO_Init(LED_PORT[Led], &gpioinitstruct);
 80001b0:	f000 fa2a 	bl	8000608 <HAL_GPIO_Init>

  /* Reset PIN to switch off the LED */
  HAL_GPIO_WritePin(LED_PORT[Led],LED_PIN[Led], GPIO_PIN_RESET);
 80001b4:	463a      	mov	r2, r7
 80001b6:	4631      	mov	r1, r6
 80001b8:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
 80001bc:	f000 fb8e 	bl	80008dc <HAL_GPIO_WritePin>
}
 80001c0:	b007      	add	sp, #28
 80001c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80001c4:	40023800 	.word	0x40023800
 80001c8:	20000004 	.word	0x20000004

080001cc <BSP_LED_On>:
  *     @arg LED2
  * @retval None
  */
void BSP_LED_On(Led_TypeDef Led)
{
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET); 
 80001cc:	4b03      	ldr	r3, [pc, #12]	; (80001dc <BSP_LED_On+0x10>)
 80001ce:	2201      	movs	r2, #1
 80001d0:	2120      	movs	r1, #32
 80001d2:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 80001d6:	f000 bb81 	b.w	80008dc <HAL_GPIO_WritePin>
 80001da:	bf00      	nop
 80001dc:	20000004 	.word	0x20000004

080001e0 <BSP_PB_Init>:
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                     generation capability  
  * @retval None
  */
void BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
 80001e0:	b510      	push	{r4, lr}
 80001e2:	b086      	sub	sp, #24
  GPIO_InitTypeDef gpioinitstruct;

  /* Enable the BUTTON Clock */
  BUTTONx_GPIO_CLK_ENABLE(Button);
 80001e4:	b948      	cbnz	r0, 80001fa <BSP_PB_Init+0x1a>
 80001e6:	4b17      	ldr	r3, [pc, #92]	; (8000244 <BSP_PB_Init+0x64>)
 80001e8:	69da      	ldr	r2, [r3, #28]
 80001ea:	f042 0204 	orr.w	r2, r2, #4
 80001ee:	61da      	str	r2, [r3, #28]
 80001f0:	69db      	ldr	r3, [r3, #28]
 80001f2:	f003 0304 	and.w	r3, r3, #4
 80001f6:	9300      	str	r3, [sp, #0]
 80001f8:	9b00      	ldr	r3, [sp, #0]

  gpioinitstruct.Pin = BUTTON_PIN[Button];
 80001fa:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80001fe:	9301      	str	r3, [sp, #4]
  gpioinitstruct.Pull = GPIO_NOPULL;
 8000200:	2400      	movs	r4, #0
  gpioinitstruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
 8000202:	2301      	movs	r3, #1

  /* Enable the BUTTON Clock */
  BUTTONx_GPIO_CLK_ENABLE(Button);

  gpioinitstruct.Pin = BUTTON_PIN[Button];
  gpioinitstruct.Pull = GPIO_NOPULL;
 8000204:	9403      	str	r4, [sp, #12]
  gpioinitstruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
 8000206:	9304      	str	r3, [sp, #16]

  if (ButtonMode == BUTTON_MODE_GPIO)
 8000208:	b939      	cbnz	r1, 800021a <BSP_PB_Init+0x3a>
  {
    /* Configure Button pin as input */
    gpioinitstruct.Mode   = GPIO_MODE_INPUT;
  
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpioinitstruct);
 800020a:	4b0f      	ldr	r3, [pc, #60]	; (8000248 <BSP_PB_Init+0x68>)
  gpioinitstruct.Speed = GPIO_SPEED_FREQ_MEDIUM;

  if (ButtonMode == BUTTON_MODE_GPIO)
  {
    /* Configure Button pin as input */
    gpioinitstruct.Mode   = GPIO_MODE_INPUT;
 800020c:	9102      	str	r1, [sp, #8]
  
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpioinitstruct);
 800020e:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8000212:	a901      	add	r1, sp, #4
 8000214:	f000 f9f8 	bl	8000608 <HAL_GPIO_Init>
 8000218:	e011      	b.n	800023e <BSP_PB_Init+0x5e>
  }
 
  if (ButtonMode == BUTTON_MODE_EXTI)
 800021a:	2901      	cmp	r1, #1
 800021c:	d10f      	bne.n	800023e <BSP_PB_Init+0x5e>
  {
    /* Configure Button pin as input with External interrupt */
    gpioinitstruct.Mode   = GPIO_MODE_IT_FALLING; 
 800021e:	4b0b      	ldr	r3, [pc, #44]	; (800024c <BSP_PB_Init+0x6c>)
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpioinitstruct);
 8000220:	a901      	add	r1, sp, #4
  }
 
  if (ButtonMode == BUTTON_MODE_EXTI)
  {
    /* Configure Button pin as input with External interrupt */
    gpioinitstruct.Mode   = GPIO_MODE_IT_FALLING; 
 8000222:	9302      	str	r3, [sp, #8]
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpioinitstruct);
 8000224:	4b08      	ldr	r3, [pc, #32]	; (8000248 <BSP_PB_Init+0x68>)
 8000226:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 800022a:	f000 f9ed 	bl	8000608 <HAL_GPIO_Init>

    /* Enable and set Button EXTI Interrupt to the lowest priority */
    HAL_NVIC_SetPriority((IRQn_Type)(BUTTON_IRQn[Button]), 0x0F, 0);
 800022e:	2028      	movs	r0, #40	; 0x28
 8000230:	4622      	mov	r2, r4
 8000232:	210f      	movs	r1, #15
 8000234:	f000 f87c 	bl	8000330 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
 8000238:	2028      	movs	r0, #40	; 0x28
 800023a:	f000 f8ad 	bl	8000398 <HAL_NVIC_EnableIRQ>
  }
}
 800023e:	b006      	add	sp, #24
 8000240:	bd10      	pop	{r4, pc}
 8000242:	bf00      	nop
 8000244:	40023800 	.word	0x40023800
 8000248:	20000000 	.word	0x20000000
 800024c:	10210000 	.word	0x10210000

08000250 <SystemInit>:
  * @retval None
  */
void SystemInit (void)
{
  /*!< Set MSION bit */
  RCC->CR |= (uint32_t)0x00000100;
 8000250:	4b0e      	ldr	r3, [pc, #56]	; (800028c <SystemInit+0x3c>)
 8000252:	681a      	ldr	r2, [r3, #0]
 8000254:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000258:	601a      	str	r2, [r3, #0]

  /*!< Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], MCOSEL[2:0] and MCOPRE[2:0] bits */
  RCC->CFGR &= (uint32_t)0x88FFC00C;
 800025a:	6899      	ldr	r1, [r3, #8]
 800025c:	4a0c      	ldr	r2, [pc, #48]	; (8000290 <SystemInit+0x40>)
 800025e:	400a      	ands	r2, r1
 8000260:	609a      	str	r2, [r3, #8]
  
  /*!< Reset HSION, HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xEEFEFFFE;
 8000262:	681a      	ldr	r2, [r3, #0]
 8000264:	f022 5288 	bic.w	r2, r2, #285212672	; 0x11000000
 8000268:	f022 1201 	bic.w	r2, r2, #65537	; 0x10001
 800026c:	601a      	str	r2, [r3, #0]

  /*!< Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800026e:	681a      	ldr	r2, [r3, #0]
 8000270:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8000274:	601a      	str	r2, [r3, #0]

  /*!< Reset PLLSRC, PLLMUL[3:0] and PLLDIV[1:0] bits */
  RCC->CFGR &= (uint32_t)0xFF02FFFF;
 8000276:	689a      	ldr	r2, [r3, #8]
 8000278:	f422 027d 	bic.w	r2, r2, #16580608	; 0xfd0000
 800027c:	609a      	str	r2, [r3, #8]

  /*!< Disable all interrupts */
  RCC->CIR = 0x00000000;
 800027e:	2200      	movs	r2, #0
 8000280:	60da      	str	r2, [r3, #12]
#endif /* DATA_IN_ExtSRAM */
    
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 8000282:	4b04      	ldr	r3, [pc, #16]	; (8000294 <SystemInit+0x44>)
 8000284:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8000288:	609a      	str	r2, [r3, #8]
 800028a:	4770      	bx	lr
 800028c:	40023800 	.word	0x40023800
 8000290:	88ffc00c 	.word	0x88ffc00c
 8000294:	e000ed00 	.word	0xe000ed00

08000298 <HAL_MspInit>:
 8000298:	4770      	bx	lr
	...

0800029c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800029c:	b510      	push	{r4, lr}
 800029e:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock /1000);
 80002a0:	4b07      	ldr	r3, [pc, #28]	; (80002c0 <HAL_InitTick+0x24>)
 80002a2:	6818      	ldr	r0, [r3, #0]
 80002a4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80002a8:	fbb0 f0f3 	udiv	r0, r0, r3
 80002ac:	f000 f88e 	bl	80003cc <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 80002b0:	2200      	movs	r2, #0
 80002b2:	4621      	mov	r1, r4
 80002b4:	f04f 30ff 	mov.w	r0, #4294967295
 80002b8:	f000 f83a 	bl	8000330 <HAL_NVIC_SetPriority>

   /* Return function status */
  return HAL_OK;
}
 80002bc:	2000      	movs	r0, #0
 80002be:	bd10      	pop	{r4, pc}
 80002c0:	20000008 	.word	0x20000008

080002c4 <HAL_Init>:
  *        In the default implementation,Systick is used as source of time base.
  *        the tick variable is incremented each 1ms in its ISR.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80002c4:	b508      	push	{r3, lr}
  /* Configure Flash prefetch */
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80002c6:	4b09      	ldr	r3, [pc, #36]	; (80002ec <HAL_Init+0x28>)
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80002c8:	2003      	movs	r0, #3
  */
HAL_StatusTypeDef HAL_Init(void)
{
  /* Configure Flash prefetch */
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80002ca:	681a      	ldr	r2, [r3, #0]
 80002cc:	f042 0204 	orr.w	r2, r2, #4
 80002d0:	601a      	str	r2, [r3, #0]
 80002d2:	681a      	ldr	r2, [r3, #0]
 80002d4:	f042 0202 	orr.w	r2, r2, #2
 80002d8:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80002da:	f000 f817 	bl	800030c <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 80002de:	200f      	movs	r0, #15
 80002e0:	f7ff ffdc 	bl	800029c <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 80002e4:	f7ff ffd8 	bl	8000298 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 80002e8:	2000      	movs	r0, #0
 80002ea:	bd08      	pop	{r3, pc}
 80002ec:	40023c00 	.word	0x40023c00

080002f0 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 80002f0:	4a02      	ldr	r2, [pc, #8]	; (80002fc <HAL_IncTick+0xc>)
 80002f2:	6813      	ldr	r3, [r2, #0]
 80002f4:	3301      	adds	r3, #1
 80002f6:	6013      	str	r3, [r2, #0]
 80002f8:	4770      	bx	lr
 80002fa:	bf00      	nop
 80002fc:	20000560 	.word	0x20000560

08000300 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000300:	4b01      	ldr	r3, [pc, #4]	; (8000308 <HAL_GetTick+0x8>)
 8000302:	6818      	ldr	r0, [r3, #0]
}
 8000304:	4770      	bx	lr
 8000306:	bf00      	nop
 8000308:	20000560 	.word	0x20000560

0800030c <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800030c:	4a07      	ldr	r2, [pc, #28]	; (800032c <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 800030e:	0200      	lsls	r0, r0, #8
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000310:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8000312:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
 8000316:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 800031a:	041b      	lsls	r3, r3, #16
 800031c:	0c1b      	lsrs	r3, r3, #16
 800031e:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8000322:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000326:	4303      	orrs	r3, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8000328:	60d3      	str	r3, [r2, #12]
 800032a:	4770      	bx	lr
 800032c:	e000ed00 	.word	0xe000ed00

08000330 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000330:	4b17      	ldr	r3, [pc, #92]	; (8000390 <HAL_NVIC_SetPriority+0x60>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8000332:	b530      	push	{r4, r5, lr}
 8000334:	68db      	ldr	r3, [r3, #12]
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8000336:	f3c3 2302 	ubfx	r3, r3, #8, #3
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800033a:	f1c3 0407 	rsb	r4, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800033e:	1d1d      	adds	r5, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000340:	2c04      	cmp	r4, #4
 8000342:	bf28      	it	cs
 8000344:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000346:	2d06      	cmp	r5, #6

  return (
 8000348:	f04f 0501 	mov.w	r5, #1
 800034c:	fa05 f404 	lsl.w	r4, r5, r4
 8000350:	f104 34ff 	add.w	r4, r4, #4294967295
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000354:	bf8c      	ite	hi
 8000356:	3b03      	subhi	r3, #3
 8000358:	2300      	movls	r3, #0

  return (
 800035a:	400c      	ands	r4, r1
 800035c:	409c      	lsls	r4, r3
 800035e:	fa05 f303 	lsl.w	r3, r5, r3
 8000362:	3b01      	subs	r3, #1
 8000364:	401a      	ands	r2, r3
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8000366:	2800      	cmp	r0, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8000368:	ea42 0204 	orr.w	r2, r2, r4
 800036c:	ea4f 1202 	mov.w	r2, r2, lsl #4
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000370:	bfaf      	iteee	ge
 8000372:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000376:	4b07      	ldrlt	r3, [pc, #28]	; (8000394 <HAL_NVIC_SetPriority+0x64>)
 8000378:	f000 000f 	andlt.w	r0, r0, #15
 800037c:	b2d2      	uxtblt	r2, r2
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800037e:	bfa5      	ittet	ge
 8000380:	b2d2      	uxtbge	r2, r2
 8000382:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000386:	541a      	strblt	r2, [r3, r0]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000388:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 800038c:	bd30      	pop	{r4, r5, pc}
 800038e:	bf00      	nop
 8000390:	e000ed00 	.word	0xe000ed00
 8000394:	e000ed14 	.word	0xe000ed14

08000398 <HAL_NVIC_EnableIRQ>:
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000398:	0942      	lsrs	r2, r0, #5
 800039a:	2301      	movs	r3, #1
 800039c:	f000 001f 	and.w	r0, r0, #31
 80003a0:	fa03 f000 	lsl.w	r0, r3, r0
 80003a4:	4b01      	ldr	r3, [pc, #4]	; (80003ac <HAL_NVIC_EnableIRQ+0x14>)
 80003a6:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 80003aa:	4770      	bx	lr
 80003ac:	e000e100 	.word	0xe000e100

080003b0 <HAL_NVIC_DisableIRQ>:
  \details Disables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80003b0:	0943      	lsrs	r3, r0, #5
 80003b2:	2201      	movs	r2, #1
 80003b4:	f000 001f 	and.w	r0, r0, #31
 80003b8:	fa02 f000 	lsl.w	r0, r2, r0
 80003bc:	4a02      	ldr	r2, [pc, #8]	; (80003c8 <HAL_NVIC_DisableIRQ+0x18>)
 80003be:	3320      	adds	r3, #32
 80003c0:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 80003c4:	4770      	bx	lr
 80003c6:	bf00      	nop
 80003c8:	e000e100 	.word	0xe000e100

080003cc <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80003cc:	3801      	subs	r0, #1
 80003ce:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80003d2:	d20a      	bcs.n	80003ea <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80003d4:	4b06      	ldr	r3, [pc, #24]	; (80003f0 <HAL_SYSTICK_Config+0x24>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80003d6:	4a07      	ldr	r2, [pc, #28]	; (80003f4 <HAL_SYSTICK_Config+0x28>)
 80003d8:	21f0      	movs	r1, #240	; 0xf0
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80003da:	6058      	str	r0, [r3, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80003dc:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80003e0:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80003e2:	2207      	movs	r2, #7
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80003e4:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80003e6:	601a      	str	r2, [r3, #0]
 80003e8:	4770      	bx	lr
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
 80003ea:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 80003ec:	4770      	bx	lr
 80003ee:	bf00      	nop
 80003f0:	e000e010 	.word	0xe000e010
 80003f4:	e000ed00 	.word	0xe000ed00

080003f8 <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{ 
 80003f8:	b510      	push	{r4, lr}
  uint32_t tmp = 0;
  
  /* Check the DMA handle allocation */
  if(hdma == NULL)
 80003fa:	2800      	cmp	r0, #0
 80003fc:	d039      	beq.n	8000472 <HAL_DMA_Init+0x7a>
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
  
#if defined (DMA2)
  /* calculation of the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 80003fe:	6801      	ldr	r1, [r0, #0]
 8000400:	4b1d      	ldr	r3, [pc, #116]	; (8000478 <HAL_DMA_Init+0x80>)
 8000402:	2414      	movs	r4, #20
 8000404:	4299      	cmp	r1, r3
 8000406:	d808      	bhi.n	800041a <HAL_DMA_Init+0x22>
  {
    /* DMA1 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 8000408:	4a1c      	ldr	r2, [pc, #112]	; (800047c <HAL_DMA_Init+0x84>)
    hdma->DmaBaseAddress = DMA1;
 800040a:	f2a3 4307 	subw	r3, r3, #1031	; 0x407
#if defined (DMA2)
  /* calculation of the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
  {
    /* DMA1 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 800040e:	440a      	add	r2, r1
 8000410:	fbb2 f2f4 	udiv	r2, r2, r4
 8000414:	0092      	lsls	r2, r2, #2
 8000416:	6402      	str	r2, [r0, #64]	; 0x40
 8000418:	e006      	b.n	8000428 <HAL_DMA_Init+0x30>
    hdma->DmaBaseAddress = DMA1;
  }
  else 
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
 800041a:	4b19      	ldr	r3, [pc, #100]	; (8000480 <HAL_DMA_Init+0x88>)
 800041c:	440b      	add	r3, r1
 800041e:	fbb3 f3f4 	udiv	r3, r3, r4
 8000422:	009b      	lsls	r3, r3, #2
 8000424:	6403      	str	r3, [r0, #64]	; 0x40
    hdma->DmaBaseAddress = DMA2;
 8000426:	4b17      	ldr	r3, [pc, #92]	; (8000484 <HAL_DMA_Init+0x8c>)
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8000428:	6882      	ldr	r2, [r0, #8]
 800042a:	6844      	ldr	r4, [r0, #4]
  }
  else 
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
    hdma->DmaBaseAddress = DMA2;
 800042c:	63c3      	str	r3, [r0, #60]	; 0x3c
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 800042e:	4314      	orrs	r4, r2
 8000430:	68c2      	ldr	r2, [r0, #12]
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
  hdma->DmaBaseAddress = DMA1;
#endif
  
  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8000432:	2302      	movs	r3, #2
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8000434:	4314      	orrs	r4, r2
 8000436:	6902      	ldr	r2, [r0, #16]
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
  hdma->DmaBaseAddress = DMA1;
#endif
  
  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8000438:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 800043c:	4314      	orrs	r4, r2
 800043e:	6942      	ldr	r2, [r0, #20]
  
  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
 8000440:	680b      	ldr	r3, [r1, #0]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8000442:	4314      	orrs	r4, r2
 8000444:	6982      	ldr	r2, [r0, #24]

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
  
  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8000446:	f423 537f 	bic.w	r3, r3, #16320	; 0x3fc0
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 800044a:	4314      	orrs	r4, r2
 800044c:	69c2      	ldr	r2, [r0, #28]

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
  
  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 800044e:	f023 0330 	bic.w	r3, r3, #48	; 0x30
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8000452:	4322      	orrs	r2, r4
 8000454:	4313      	orrs	r3, r2
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
          hdma->Init.Mode                | hdma->Init.Priority;

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;  
 8000456:	600b      	str	r3, [r1, #0]

  /* Initialise the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;

  /* Initialize the DMA state*/
  hdma->State = HAL_DMA_STATE_READY;
 8000458:	2201      	movs	r2, #1

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;  
  
  /* Clean callbacks */
  hdma->XferCpltCallback = NULL;
 800045a:	2300      	movs	r3, #0
  hdma->XferHalfCpltCallback = NULL;
  hdma->XferErrorCallback = NULL;
  hdma->XferAbortCallback = NULL;

  /* Initialise the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800045c:	6383      	str	r3, [r0, #56]	; 0x38

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;  
  
  /* Clean callbacks */
  hdma->XferCpltCallback = NULL;
 800045e:	6283      	str	r3, [r0, #40]	; 0x28
  hdma->XferHalfCpltCallback = NULL;
 8000460:	62c3      	str	r3, [r0, #44]	; 0x2c
  hdma->XferErrorCallback = NULL;
 8000462:	6303      	str	r3, [r0, #48]	; 0x30
  hdma->XferAbortCallback = NULL;
 8000464:	6343      	str	r3, [r0, #52]	; 0x34

  /* Initialise the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;

  /* Initialize the DMA state*/
  hdma->State = HAL_DMA_STATE_READY;
 8000466:	f880 2021 	strb.w	r2, [r0, #33]	; 0x21
  
  /* Allocate lock resource and initialize it */
  hdma->Lock = HAL_UNLOCKED;
 800046a:	f880 3020 	strb.w	r3, [r0, #32]
  
  return HAL_OK;
 800046e:	4618      	mov	r0, r3
 8000470:	bd10      	pop	{r4, pc}
  uint32_t tmp = 0;
  
  /* Check the DMA handle allocation */
  if(hdma == NULL)
  {
    return HAL_ERROR;
 8000472:	2001      	movs	r0, #1
  
  /* Allocate lock resource and initialize it */
  hdma->Lock = HAL_UNLOCKED;
  
  return HAL_OK;
}
 8000474:	bd10      	pop	{r4, pc}
 8000476:	bf00      	nop
 8000478:	40026407 	.word	0x40026407
 800047c:	bffd9ff8 	.word	0xbffd9ff8
 8000480:	bffd9bf8 	.word	0xbffd9bf8
 8000484:	40026400 	.word	0x40026400

08000488 <HAL_DMA_DeInit>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
 8000488:	b510      	push	{r4, lr}
  /* Check the DMA handle allocation */
  if (NULL == hdma )
 800048a:	b350      	cbz	r0, 80004e2 <HAL_DMA_DeInit+0x5a>

  /* Check the parameters */
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));

  /* Disable the selected DMA Channelx */
  __HAL_DMA_DISABLE(hdma);
 800048c:	6802      	ldr	r2, [r0, #0]
 800048e:	2414      	movs	r4, #20
 8000490:	6813      	ldr	r3, [r2, #0]
 8000492:	f023 0301 	bic.w	r3, r3, #1
 8000496:	6013      	str	r3, [r2, #0]

#if defined (DMA2)
  /* calculation of the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8000498:	4b13      	ldr	r3, [pc, #76]	; (80004e8 <HAL_DMA_DeInit+0x60>)
 800049a:	429a      	cmp	r2, r3
 800049c:	d808      	bhi.n	80004b0 <HAL_DMA_DeInit+0x28>
  {
    /* DMA1 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 800049e:	4913      	ldr	r1, [pc, #76]	; (80004ec <HAL_DMA_DeInit+0x64>)
    hdma->DmaBaseAddress = DMA1;
 80004a0:	f2a3 4307 	subw	r3, r3, #1031	; 0x407
#if defined (DMA2)
  /* calculation of the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
  {
    /* DMA1 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 80004a4:	4411      	add	r1, r2
 80004a6:	fbb1 f1f4 	udiv	r1, r1, r4
 80004aa:	0089      	lsls	r1, r1, #2
 80004ac:	6401      	str	r1, [r0, #64]	; 0x40
 80004ae:	e006      	b.n	80004be <HAL_DMA_DeInit+0x36>
    hdma->DmaBaseAddress = DMA1;
  }
  else 
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
 80004b0:	4b0f      	ldr	r3, [pc, #60]	; (80004f0 <HAL_DMA_DeInit+0x68>)
 80004b2:	4413      	add	r3, r2
 80004b4:	fbb3 f3f4 	udiv	r3, r3, r4
 80004b8:	009b      	lsls	r3, r3, #2
 80004ba:	6403      	str	r3, [r0, #64]	; 0x40
    hdma->DmaBaseAddress = DMA2;
 80004bc:	4b0d      	ldr	r3, [pc, #52]	; (80004f4 <HAL_DMA_DeInit+0x6c>)
 80004be:	63c3      	str	r3, [r0, #60]	; 0x3c

  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR = ((DMA_ISR_GIF1) << (hdma->ChannelIndex));
 80004c0:	6c04      	ldr	r4, [r0, #64]	; 0x40
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
  hdma->DmaBaseAddress = DMA1;
#endif
  
  /* Reset DMA Channel control register */
  hdma->Instance->CCR  = 0;
 80004c2:	2300      	movs	r3, #0
 80004c4:	6013      	str	r3, [r2, #0]

  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR = ((DMA_ISR_GIF1) << (hdma->ChannelIndex));
 80004c6:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
  
  /* Reset DMA Channel control register */
  hdma->Instance->CCR  = 0;

  /* Reset DMA Channel Number of Data to Transfer register */
  hdma->Instance->CNDTR = 0;
 80004c8:	6053      	str	r3, [r2, #4]

  /* Reset DMA Channel peripheral address register */
  hdma->Instance->CPAR  = 0;
 80004ca:	6093      	str	r3, [r2, #8]

  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;
 80004cc:	60d3      	str	r3, [r2, #12]

  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR = ((DMA_ISR_GIF1) << (hdma->ChannelIndex));
 80004ce:	2201      	movs	r2, #1
 80004d0:	40a2      	lsls	r2, r4
 80004d2:	604a      	str	r2, [r1, #4]

/* Initialise the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80004d4:	6383      	str	r3, [r0, #56]	; 0x38

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hdma);
 80004d6:	f880 3020 	strb.w	r3, [r0, #32]

/* Initialise the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;
 80004da:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21

  /* Release Lock */
  __HAL_UNLOCK(hdma);

  return HAL_OK;
 80004de:	4618      	mov	r0, r3
 80004e0:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
  /* Check the DMA handle allocation */
  if (NULL == hdma )
  {
    return HAL_ERROR;
 80004e2:	2001      	movs	r0, #1

  /* Release Lock */
  __HAL_UNLOCK(hdma);

  return HAL_OK;
}
 80004e4:	bd10      	pop	{r4, pc}
 80004e6:	bf00      	nop
 80004e8:	40026407 	.word	0x40026407
 80004ec:	bffd9ff8 	.word	0xbffd9ff8
 80004f0:	bffd9bf8 	.word	0xbffd9bf8
 80004f4:	40026400 	.word	0x40026400

080004f8 <HAL_DMA_Start_IT>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 80004f8:	b5f0      	push	{r4, r5, r6, r7, lr}

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Process locked */
  __HAL_LOCK(hdma);
 80004fa:	f890 4020 	ldrb.w	r4, [r0, #32]
 80004fe:	2c01      	cmp	r4, #1
 8000500:	d038      	beq.n	8000574 <HAL_DMA_Start_IT+0x7c>

  if(HAL_DMA_STATE_READY == hdma->State)
 8000502:	f890 5021 	ldrb.w	r5, [r0, #33]	; 0x21

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Process locked */
  __HAL_LOCK(hdma);
 8000506:	2401      	movs	r4, #1

  if(HAL_DMA_STATE_READY == hdma->State)
 8000508:	b2ed      	uxtb	r5, r5
 800050a:	42a5      	cmp	r5, r4

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Process locked */
  __HAL_LOCK(hdma);
 800050c:	f880 4020 	strb.w	r4, [r0, #32]
 8000510:	f04f 0600 	mov.w	r6, #0
 8000514:	f04f 0402 	mov.w	r4, #2

  if(HAL_DMA_STATE_READY == hdma->State)
 8000518:	d128      	bne.n	800056c <HAL_DMA_Start_IT+0x74>
  {
  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 800051a:	f880 4021 	strb.w	r4, [r0, #33]	; 0x21
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 800051e:	6804      	ldr	r4, [r0, #0]

  if(HAL_DMA_STATE_READY == hdma->State)
  {
  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8000520:	6386      	str	r6, [r0, #56]	; 0x38
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 8000522:	6826      	ldr	r6, [r4, #0]
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR  = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8000524:	6c07      	ldr	r7, [r0, #64]	; 0x40
  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 8000526:	f026 0601 	bic.w	r6, r6, #1
 800052a:	6026      	str	r6, [r4, #0]
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR  = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 800052c:	6bc6      	ldr	r6, [r0, #60]	; 0x3c
 800052e:	40bd      	lsls	r5, r7
 8000530:	6075      	str	r5, [r6, #4]
  
  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;
 8000532:	6063      	str	r3, [r4, #4]
  
  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8000534:	6843      	ldr	r3, [r0, #4]
 8000536:	6805      	ldr	r5, [r0, #0]
 8000538:	2b10      	cmp	r3, #16
    /* Configure the source, destination address and the data length & clear flags*/
  DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
  
  /* Enable the transfer complete interrupt */
  /* Enable the transfer Error interrupt */
    if(NULL != hdma->XferHalfCpltCallback )
 800053a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  
  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
  {
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;
 800053c:	bf0b      	itete	eq
 800053e:	60a2      	streq	r2, [r4, #8]
  }
  /* Memory to Peripheral */
  else
  {
    /* Configure DMA Channel source address */
    hdma->Instance->CPAR = SrcAddress;
 8000540:	60a1      	strne	r1, [r4, #8]
  {
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;
    
    /* Configure DMA Channel source address */
    hdma->Instance->CMAR = SrcAddress;
 8000542:	60e1      	streq	r1, [r4, #12]
  {
    /* Configure DMA Channel source address */
    hdma->Instance->CPAR = SrcAddress;
    
    /* Configure DMA Channel destination address */
    hdma->Instance->CMAR = DstAddress;
 8000544:	60e2      	strne	r2, [r4, #12]
    /* Configure the source, destination address and the data length & clear flags*/
  DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
  
  /* Enable the transfer complete interrupt */
  /* Enable the transfer Error interrupt */
    if(NULL != hdma->XferHalfCpltCallback )
 8000546:	b11b      	cbz	r3, 8000550 <HAL_DMA_Start_IT+0x58>
    {
      /* Enable the Half transfer complete interrupt as well */
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8000548:	6823      	ldr	r3, [r4, #0]
 800054a:	f043 030e 	orr.w	r3, r3, #14
 800054e:	e006      	b.n	800055e <HAL_DMA_Start_IT+0x66>
    }
    else
    {
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8000550:	6823      	ldr	r3, [r4, #0]
 8000552:	f023 0304 	bic.w	r3, r3, #4
 8000556:	6023      	str	r3, [r4, #0]
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 8000558:	6823      	ldr	r3, [r4, #0]
 800055a:	f043 030a 	orr.w	r3, r3, #10
 800055e:	6023      	str	r3, [r4, #0]
    }
   /* Enable the Peripheral */
  __HAL_DMA_ENABLE(hdma);
 8000560:	682b      	ldr	r3, [r5, #0]
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
  HAL_StatusTypeDef status = HAL_OK;
 8000562:	2000      	movs	r0, #0
    {
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
    }
   /* Enable the Peripheral */
  __HAL_DMA_ENABLE(hdma);
 8000564:	f043 0301 	orr.w	r3, r3, #1
 8000568:	602b      	str	r3, [r5, #0]
 800056a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  }
  else
  {      
    /* Process Unlocked */
    __HAL_UNLOCK(hdma); 
 800056c:	f880 6020 	strb.w	r6, [r0, #32]
  
    /* Remain BUSY */
    status = HAL_BUSY;
 8000570:	4620      	mov	r0, r4
 8000572:	bdf0      	pop	{r4, r5, r6, r7, pc}

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Process locked */
  __HAL_LOCK(hdma);
 8000574:	2002      	movs	r0, #2
  
    /* Remain BUSY */
    status = HAL_BUSY;
  }    
  return status;
} 
 8000576:	bdf0      	pop	{r4, r5, r6, r7, pc}

08000578 <HAL_DMA_IRQHandler>:
  *               the configuration information for the specified DMA Channel.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 8000578:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
  uint32_t source_it = hdma->Instance->CCR;
      
  /* Half Transfer Complete Interrupt management ******************************/
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 800057a:	6c02      	ldr	r2, [r0, #64]	; 0x40
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 800057c:	b470      	push	{r4, r5, r6}
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 800057e:	680e      	ldr	r6, [r1, #0]
  uint32_t source_it = hdma->Instance->CCR;
      
  /* Half Transfer Complete Interrupt management ******************************/
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 8000580:	2404      	movs	r4, #4
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
  uint32_t source_it = hdma->Instance->CCR;
 8000582:	6803      	ldr	r3, [r0, #0]
      
  /* Half Transfer Complete Interrupt management ******************************/
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 8000584:	4094      	lsls	r4, r2
 8000586:	4226      	tst	r6, r4
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
  uint32_t source_it = hdma->Instance->CCR;
 8000588:	681d      	ldr	r5, [r3, #0]
      
  /* Half Transfer Complete Interrupt management ******************************/
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 800058a:	d00c      	beq.n	80005a6 <HAL_DMA_IRQHandler+0x2e>
 800058c:	f015 0f04 	tst.w	r5, #4
 8000590:	d009      	beq.n	80005a6 <HAL_DMA_IRQHandler+0x2e>
    { 
      /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
      if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
 8000592:	681a      	ldr	r2, [r3, #0]
 8000594:	0692      	lsls	r2, r2, #26
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8000596:	bf5e      	ittt	pl
 8000598:	681a      	ldrpl	r2, [r3, #0]
 800059a:	f022 0204 	bicpl.w	r2, r2, #4
 800059e:	601a      	strpl	r2, [r3, #0]
      }
      /* Clear the half transfer complete flag */
      hdma->DmaBaseAddress->IFCR  = (DMA_ISR_HTIF1 << hdma->ChannelIndex);
 80005a0:	604c      	str	r4, [r1, #4]

      /* DMA peripheral state is not updated in Half Transfer */
      /* but in Transfer Complete case */

      if(hdma->XferHalfCpltCallback != NULL)
 80005a2:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80005a4:	e02b      	b.n	80005fe <HAL_DMA_IRQHandler+0x86>
        hdma->XferHalfCpltCallback(hdma);
      }
    }
  
  /* Transfer Complete Interrupt management ***********************************/
  else if ((RESET != (flag_it & (DMA_FLAG_TC1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TC)))
 80005a6:	2402      	movs	r4, #2
 80005a8:	4094      	lsls	r4, r2
 80005aa:	4226      	tst	r6, r4
 80005ac:	d012      	beq.n	80005d4 <HAL_DMA_IRQHandler+0x5c>
 80005ae:	f015 0f02 	tst.w	r5, #2
 80005b2:	d00f      	beq.n	80005d4 <HAL_DMA_IRQHandler+0x5c>
  {
    if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
 80005b4:	681a      	ldr	r2, [r3, #0]
 80005b6:	0695      	lsls	r5, r2, #26
 80005b8:	d406      	bmi.n	80005c8 <HAL_DMA_IRQHandler+0x50>
    {
    /* Disable TE & TC */
    __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);  
 80005ba:	681a      	ldr	r2, [r3, #0]
 80005bc:	f022 020a 	bic.w	r2, r2, #10
 80005c0:	601a      	str	r2, [r3, #0]

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 80005c2:	2301      	movs	r3, #1
 80005c4:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
    
    /* Clear the transfer complete flag */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_TCIF1 << hdma->ChannelIndex);
  
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 80005c8:	2300      	movs	r3, #0
    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
    }
    
    /* Clear the transfer complete flag */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_TCIF1 << hdma->ChannelIndex);
 80005ca:	604c      	str	r4, [r1, #4]
  
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 80005cc:	f880 3020 	strb.w	r3, [r0, #32]

    if(hdma->XferCpltCallback != NULL)
 80005d0:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80005d2:	e014      	b.n	80005fe <HAL_DMA_IRQHandler+0x86>
      hdma->XferCpltCallback(hdma);
    }
  }

  /* Transfer Error Interrupt management **************************************/
  else if (( RESET != (flag_it & (DMA_FLAG_TE1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TE)))
 80005d4:	2408      	movs	r4, #8
 80005d6:	4094      	lsls	r4, r2
 80005d8:	4234      	tst	r4, r6
 80005da:	d013      	beq.n	8000604 <HAL_DMA_IRQHandler+0x8c>
 80005dc:	072c      	lsls	r4, r5, #28
 80005de:	d511      	bpl.n	8000604 <HAL_DMA_IRQHandler+0x8c>
  {
    /* When a DMA transfer error occurs */
    /* A hardware clear of its EN bits is performed */
    /* Disable ALL DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80005e0:	681c      	ldr	r4, [r3, #0]
 80005e2:	f024 040e 	bic.w	r4, r4, #14
 80005e6:	601c      	str	r4, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR  = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 80005e8:	2301      	movs	r3, #1
 80005ea:	fa03 f202 	lsl.w	r2, r3, r2
 80005ee:	604a      	str	r2, [r1, #4]

      /* Update error code */
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 80005f0:	6383      	str	r3, [r0, #56]	; 0x38

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 80005f2:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
    
      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 80005f6:	2300      	movs	r3, #0
 80005f8:	f880 3020 	strb.w	r3, [r0, #32]
    
    if (hdma->XferErrorCallback != NULL)
 80005fc:	6b03      	ldr	r3, [r0, #48]	; 0x30
 80005fe:	b10b      	cbz	r3, 8000604 <HAL_DMA_IRQHandler+0x8c>
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
      }
    }
  return;
}
 8000600:	bc70      	pop	{r4, r5, r6}
      __HAL_UNLOCK(hdma);
    
    if (hdma->XferErrorCallback != NULL)
      {       
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 8000602:	4718      	bx	r3
      }
    }
  return;
}
 8000604:	bc70      	pop	{r4, r5, r6}
 8000606:	4770      	bx	lr

08000608 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{ 
 8000608:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;
                  
        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800060c:	f8df 819c 	ldr.w	r8, [pc, #412]	; 80007ac <HAL_GPIO_Init+0x1a4>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull)); 

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0)
 8000610:	680b      	ldr	r3, [r1, #0]
 8000612:	4644      	mov	r4, r8
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{ 
 8000614:	b085      	sub	sp, #20
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000616:	f8df c198 	ldr.w	ip, [pc, #408]	; 80007b0 <HAL_GPIO_Init+0x1a8>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull)); 

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0)
 800061a:	9301      	str	r3, [sp, #4]
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{ 
  uint32_t position = 0x00;
 800061c:	2300      	movs	r3, #0
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull)); 

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0)
 800061e:	9a01      	ldr	r2, [sp, #4]
 8000620:	40da      	lsrs	r2, r3
 8000622:	f000 80be 	beq.w	80007a2 <HAL_GPIO_Init+0x19a>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & ((uint32_t)1 << position);
 8000626:	f04f 0e01 	mov.w	lr, #1
    
    if(iocurrent)
 800062a:	9a01      	ldr	r2, [sp, #4]

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0)
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & ((uint32_t)1 << position);
 800062c:	fa0e fe03 	lsl.w	lr, lr, r3
    
    if(iocurrent)
 8000630:	ea12 060e 	ands.w	r6, r2, lr
 8000634:	f000 80b3 	beq.w	800079e <HAL_GPIO_Init+0x196>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) 
 8000638:	684a      	ldr	r2, [r1, #4]
 800063a:	f022 0910 	bic.w	r9, r2, #16
 800063e:	f1b9 0f02 	cmp.w	r9, #2
 8000642:	d114      	bne.n	800066e <HAL_GPIO_Init+0x66>
 8000644:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 8000648:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */ 
        /* Identify AFRL or AFRH register based on IO position*/
        temp = GPIOx->AFR[position >> 3];
        CLEAR_BIT(temp, (uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;      
 800064c:	f003 0b07 	and.w	fp, r3, #7
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */ 
        /* Identify AFRL or AFRH register based on IO position*/
        temp = GPIOx->AFR[position >> 3];
 8000650:	f8da 7020 	ldr.w	r7, [sl, #32]
        CLEAR_BIT(temp, (uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;      
 8000654:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 8000658:	250f      	movs	r5, #15
 800065a:	fa05 f50b 	lsl.w	r5, r5, fp
 800065e:	ea27 0505 	bic.w	r5, r7, r5
        SET_BIT(temp, (uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));       
 8000662:	690f      	ldr	r7, [r1, #16]
 8000664:	fa07 f70b 	lsl.w	r7, r7, fp
 8000668:	432f      	orrs	r7, r5
        GPIOx->AFR[position >> 3] = temp;
 800066a:	f8ca 7020 	str.w	r7, [sl, #32]
 800066e:	ea4f 0a43 	mov.w	sl, r3, lsl #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2));   
 8000672:	2503      	movs	r5, #3
 8000674:	fa05 f50a 	lsl.w	r5, r5, sl
 8000678:	43ed      	mvns	r5, r5
        SET_BIT(temp, (uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));       
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800067a:	6807      	ldr	r7, [r0, #0]
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2));   
      SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800067c:	f002 0b03 	and.w	fp, r2, #3
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2));   
 8000680:	402f      	ands	r7, r5
      SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000682:	fa0b fb0a 	lsl.w	fp, fp, sl
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000686:	f109 39ff 	add.w	r9, r9, #4294967295
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2));   
      SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800068a:	ea4b 0707 	orr.w	r7, fp, r7
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800068e:	f1b9 0f01 	cmp.w	r9, #1

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2));   
      SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2));
      GPIOx->MODER = temp;
 8000692:	6007      	str	r7, [r0, #0]

      /* In case of Output or Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000694:	d811      	bhi.n	80006ba <HAL_GPIO_Init+0xb2>
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8000696:	6887      	ldr	r7, [r0, #8]
        CLEAR_BIT(temp, GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8000698:	ea05 0907 	and.w	r9, r5, r7
        SET_BIT(temp, GPIO_Init->Speed << (position * 2));
 800069c:	68cf      	ldr	r7, [r1, #12]
 800069e:	fa07 f70a 	lsl.w	r7, r7, sl
 80006a2:	ea47 0709 	orr.w	r7, r7, r9
        GPIOx->OSPEEDR = temp;
 80006a6:	6087      	str	r7, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 80006a8:	6847      	ldr	r7, [r0, #4]
        CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
 80006aa:	ea27 0e0e 	bic.w	lr, r7, lr
        SET_BIT(temp, ((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 80006ae:	f3c2 1700 	ubfx	r7, r2, #4, #1
 80006b2:	409f      	lsls	r7, r3
 80006b4:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
 80006b8:	6047      	str	r7, [r0, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 80006ba:	68c7      	ldr	r7, [r0, #12]
      CLEAR_BIT(temp, GPIO_PUPDR_PUPDR0 << (position * 2));
 80006bc:	403d      	ands	r5, r7
      SET_BIT(temp, (GPIO_Init->Pull) << (position * 2));
 80006be:	688f      	ldr	r7, [r1, #8]
 80006c0:	fa07 f70a 	lsl.w	r7, r7, sl
 80006c4:	433d      	orrs	r5, r7
      GPIOx->PUPDR = temp;
 80006c6:	60c5      	str	r5, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 80006c8:	00d5      	lsls	r5, r2, #3
 80006ca:	d568      	bpl.n	800079e <HAL_GPIO_Init+0x196>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80006cc:	f8dc 5020 	ldr.w	r5, [ip, #32]
 80006d0:	f023 0703 	bic.w	r7, r3, #3
 80006d4:	f045 0501 	orr.w	r5, r5, #1
 80006d8:	f8cc 5020 	str.w	r5, [ip, #32]
 80006dc:	f8dc 5020 	ldr.w	r5, [ip, #32]
 80006e0:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 80006e4:	f005 0501 	and.w	r5, r5, #1
 80006e8:	9503      	str	r5, [sp, #12]
 80006ea:	f507 3780 	add.w	r7, r7, #65536	; 0x10000
        
        temp = SYSCFG->EXTICR[position >> 2];
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
 80006ee:	f003 0903 	and.w	r9, r3, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80006f2:	9d03      	ldr	r5, [sp, #12]
        
        temp = SYSCFG->EXTICR[position >> 2];
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
 80006f4:	f04f 0e0f 	mov.w	lr, #15
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
        
        temp = SYSCFG->EXTICR[position >> 2];
 80006f8:	f8d7 a008 	ldr.w	sl, [r7, #8]
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
 80006fc:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8000700:	fa0e f509 	lsl.w	r5, lr, r9
 8000704:	ea2a 0e05 	bic.w	lr, sl, r5
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8000708:	4d27      	ldr	r5, [pc, #156]	; (80007a8 <HAL_GPIO_Init+0x1a0>)
 800070a:	42a8      	cmp	r0, r5
 800070c:	d01a      	beq.n	8000744 <HAL_GPIO_Init+0x13c>
 800070e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000712:	42a8      	cmp	r0, r5
 8000714:	d018      	beq.n	8000748 <HAL_GPIO_Init+0x140>
 8000716:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800071a:	42a8      	cmp	r0, r5
 800071c:	d016      	beq.n	800074c <HAL_GPIO_Init+0x144>
 800071e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000722:	42a8      	cmp	r0, r5
 8000724:	d014      	beq.n	8000750 <HAL_GPIO_Init+0x148>
 8000726:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800072a:	42a8      	cmp	r0, r5
 800072c:	d012      	beq.n	8000754 <HAL_GPIO_Init+0x14c>
 800072e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000732:	42a8      	cmp	r0, r5
 8000734:	d010      	beq.n	8000758 <HAL_GPIO_Init+0x150>
 8000736:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800073a:	42a8      	cmp	r0, r5
 800073c:	bf14      	ite	ne
 800073e:	2507      	movne	r5, #7
 8000740:	2506      	moveq	r5, #6
 8000742:	e00a      	b.n	800075a <HAL_GPIO_Init+0x152>
 8000744:	2500      	movs	r5, #0
 8000746:	e008      	b.n	800075a <HAL_GPIO_Init+0x152>
 8000748:	2501      	movs	r5, #1
 800074a:	e006      	b.n	800075a <HAL_GPIO_Init+0x152>
 800074c:	2502      	movs	r5, #2
 800074e:	e004      	b.n	800075a <HAL_GPIO_Init+0x152>
 8000750:	2503      	movs	r5, #3
 8000752:	e002      	b.n	800075a <HAL_GPIO_Init+0x152>
 8000754:	2504      	movs	r5, #4
 8000756:	e000      	b.n	800075a <HAL_GPIO_Init+0x152>
 8000758:	2505      	movs	r5, #5
 800075a:	fa05 f509 	lsl.w	r5, r5, r9
 800075e:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2] = temp;
 8000762:	60bd      	str	r5, [r7, #8]
                  
        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 8000764:	43f7      	mvns	r7, r6
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;
                  
        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000766:	f8d8 5000 	ldr.w	r5, [r8]
        CLEAR_BIT(temp, (uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800076a:	f412 3f80 	tst.w	r2, #65536	; 0x10000
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;
                  
        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 800076e:	bf0c      	ite	eq
 8000770:	403d      	andeq	r5, r7
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          SET_BIT(temp, iocurrent); 
 8000772:	4335      	orrne	r5, r6
        }
        EXTI->IMR = temp;
 8000774:	6025      	str	r5, [r4, #0]

        temp = EXTI->EMR;
 8000776:	6865      	ldr	r5, [r4, #4]
        CLEAR_BIT(temp, (uint32_t)iocurrent);      
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8000778:	f412 3f00 	tst.w	r2, #131072	; 0x20000
          SET_BIT(temp, iocurrent); 
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        CLEAR_BIT(temp, (uint32_t)iocurrent);      
 800077c:	bf0c      	ite	eq
 800077e:	403d      	andeq	r5, r7
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          SET_BIT(temp, iocurrent); 
 8000780:	4335      	orrne	r5, r6
        }
        EXTI->EMR = temp;
 8000782:	6065      	str	r5, [r4, #4]
  
        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8000784:	68a5      	ldr	r5, [r4, #8]
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8000786:	f412 1f80 	tst.w	r2, #1048576	; 0x100000
        }
        EXTI->EMR = temp;
  
        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
 800078a:	bf0c      	ite	eq
 800078c:	403d      	andeq	r5, r7
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          SET_BIT(temp, iocurrent); 
 800078e:	4335      	orrne	r5, r6
        }
        EXTI->RTSR = temp;
 8000790:	60a5      	str	r5, [r4, #8]

        temp = EXTI->FTSR;
 8000792:	68e5      	ldr	r5, [r4, #12]
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8000794:	0292      	lsls	r2, r2, #10
          SET_BIT(temp, iocurrent); 
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
 8000796:	bf54      	ite	pl
 8000798:	403d      	andpl	r5, r7
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          SET_BIT(temp, iocurrent); 
 800079a:	4335      	orrmi	r5, r6
        }
        EXTI->FTSR = temp;
 800079c:	60e5      	str	r5, [r4, #12]
      }
    }
    
    position++;
 800079e:	3301      	adds	r3, #1
 80007a0:	e73d      	b.n	800061e <HAL_GPIO_Init+0x16>
  } 
}
 80007a2:	b005      	add	sp, #20
 80007a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80007a8:	40020000 	.word	0x40020000
 80007ac:	40010400 	.word	0x40010400
 80007b0:	40023800 	.word	0x40023800

080007b4 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 80007b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      {
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        CLEAR_BIT(SYSCFG->EXTICR[position >> 2], tmp);
        
        /* Clear EXTI line configuration */
        CLEAR_BIT(EXTI->IMR, (uint32_t)iocurrent);
 80007b8:	4c44      	ldr	r4, [pc, #272]	; (80008cc <HAL_GPIO_DeInit+0x118>)
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 80007ba:	f8df a118 	ldr.w	sl, [pc, #280]	; 80008d4 <HAL_GPIO_DeInit+0x120>
 80007be:	f8df b118 	ldr.w	fp, [pc, #280]	; 80008d8 <HAL_GPIO_DeInit+0x124>
  *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
  uint32_t position = 0x00;
 80007c2:	2200      	movs	r2, #0

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0)
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & ((uint32_t)1 << position);
 80007c4:	f04f 0901 	mov.w	r9, #1
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0)
 80007c8:	fa31 f302 	lsrs.w	r3, r1, r2
 80007cc:	d07b      	beq.n	80008c6 <HAL_GPIO_DeInit+0x112>
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & ((uint32_t)1 << position);
 80007ce:	fa09 f802 	lsl.w	r8, r9, r2

    if (iocurrent)
 80007d2:	ea11 0608 	ands.w	r6, r1, r8
 80007d6:	d074      	beq.n	80008c2 <HAL_GPIO_DeInit+0x10e>
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO Direction in Input Floting Mode */
      CLEAR_BIT(GPIOx->MODER, GPIO_MODER_MODER0 << (position * 2)); 
 80007d8:	2303      	movs	r3, #3
 80007da:	0055      	lsls	r5, r2, #1
 80007dc:	fa03 f505 	lsl.w	r5, r3, r5
 80007e0:	43ed      	mvns	r5, r5
 80007e2:	6807      	ldr	r7, [r0, #0]
 80007e4:	fa22 fc03 	lsr.w	ip, r2, r3
 80007e8:	402f      	ands	r7, r5
 80007ea:	6007      	str	r7, [r0, #0]
 80007ec:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
  
      /* Configure the default Alternate Function in current IO */ 
      CLEAR_BIT(GPIOx->AFR[position >> 3], (uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 80007f0:	f8dc 7020 	ldr.w	r7, [ip, #32]
 80007f4:	f002 0e07 	and.w	lr, r2, #7
 80007f8:	463b      	mov	r3, r7
 80007fa:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 80007fe:	270f      	movs	r7, #15
 8000800:	fa07 fe0e 	lsl.w	lr, r7, lr
 8000804:	ea23 0e0e 	bic.w	lr, r3, lr
 8000808:	f8cc e020 	str.w	lr, [ip, #32]
  
      /* Configure the default value for IO Speed */
      CLEAR_BIT(GPIOx->OSPEEDR, GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 800080c:	f8d0 e008 	ldr.w	lr, [r0, #8]
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 8000810:	4b2f      	ldr	r3, [pc, #188]	; (80008d0 <HAL_GPIO_DeInit+0x11c>)
  
      /* Configure the default Alternate Function in current IO */ 
      CLEAR_BIT(GPIOx->AFR[position >> 3], (uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
  
      /* Configure the default value for IO Speed */
      CLEAR_BIT(GPIOx->OSPEEDR, GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8000812:	ea05 0e0e 	and.w	lr, r5, lr
 8000816:	f8c0 e008 	str.w	lr, [r0, #8]
                  
      /* Configure the default value IO Output Type */
      CLEAR_BIT(GPIOx->OTYPER, GPIO_OTYPER_OT_0 << position) ;
 800081a:	f8d0 e004 	ldr.w	lr, [r0, #4]
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 800081e:	4298      	cmp	r0, r3
  
      /* Configure the default value for IO Speed */
      CLEAR_BIT(GPIOx->OSPEEDR, GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
                  
      /* Configure the default value IO Output Type */
      CLEAR_BIT(GPIOx->OTYPER, GPIO_OTYPER_OT_0 << position) ;
 8000820:	ea2e 0808 	bic.w	r8, lr, r8
 8000824:	f8c0 8004 	str.w	r8, [r0, #4]
  
      /* Deactivate the Pull-up oand Pull-down resistor for the current IO */
      CLEAR_BIT(GPIOx->PUPDR, GPIO_PUPDR_PUPDR0 << (position * 2));
 8000828:	f8d0 e00c 	ldr.w	lr, [r0, #12]
 800082c:	ea05 050e 	and.w	r5, r5, lr
 8000830:	60c5      	str	r5, [r0, #12]
 8000832:	f022 0503 	bic.w	r5, r2, #3
 8000836:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 800083a:	f505 3580 	add.w	r5, r5, #65536	; 0x10000

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 800083e:	f002 0e03 	and.w	lr, r2, #3
      CLEAR_BIT(GPIOx->PUPDR, GPIO_PUPDR_PUPDR0 << (position * 2));

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = SYSCFG->EXTICR[position >> 2];
 8000842:	f8d5 c008 	ldr.w	ip, [r5, #8]
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000846:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 800084a:	fa07 f70e 	lsl.w	r7, r7, lr
 800084e:	ea0c 0c07 	and.w	ip, ip, r7
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 8000852:	d016      	beq.n	8000882 <HAL_GPIO_DeInit+0xce>
 8000854:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000858:	4298      	cmp	r0, r3
 800085a:	d014      	beq.n	8000886 <HAL_GPIO_DeInit+0xd2>
 800085c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000860:	4298      	cmp	r0, r3
 8000862:	d012      	beq.n	800088a <HAL_GPIO_DeInit+0xd6>
 8000864:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000868:	4298      	cmp	r0, r3
 800086a:	d010      	beq.n	800088e <HAL_GPIO_DeInit+0xda>
 800086c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000870:	4298      	cmp	r0, r3
 8000872:	d00e      	beq.n	8000892 <HAL_GPIO_DeInit+0xde>
 8000874:	4550      	cmp	r0, sl
 8000876:	d00e      	beq.n	8000896 <HAL_GPIO_DeInit+0xe2>
 8000878:	4558      	cmp	r0, fp
 800087a:	bf0c      	ite	eq
 800087c:	2306      	moveq	r3, #6
 800087e:	2307      	movne	r3, #7
 8000880:	e00a      	b.n	8000898 <HAL_GPIO_DeInit+0xe4>
 8000882:	2300      	movs	r3, #0
 8000884:	e008      	b.n	8000898 <HAL_GPIO_DeInit+0xe4>
 8000886:	2301      	movs	r3, #1
 8000888:	e006      	b.n	8000898 <HAL_GPIO_DeInit+0xe4>
 800088a:	2302      	movs	r3, #2
 800088c:	e004      	b.n	8000898 <HAL_GPIO_DeInit+0xe4>
 800088e:	2303      	movs	r3, #3
 8000890:	e002      	b.n	8000898 <HAL_GPIO_DeInit+0xe4>
 8000892:	2304      	movs	r3, #4
 8000894:	e000      	b.n	8000898 <HAL_GPIO_DeInit+0xe4>
 8000896:	2305      	movs	r3, #5
 8000898:	fa03 f30e 	lsl.w	r3, r3, lr
 800089c:	459c      	cmp	ip, r3
 800089e:	d110      	bne.n	80008c2 <HAL_GPIO_DeInit+0x10e>
      {
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        CLEAR_BIT(SYSCFG->EXTICR[position >> 2], tmp);
        
        /* Clear EXTI line configuration */
        CLEAR_BIT(EXTI->IMR, (uint32_t)iocurrent);
 80008a0:	43f6      	mvns	r6, r6
      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
      {
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        CLEAR_BIT(SYSCFG->EXTICR[position >> 2], tmp);
 80008a2:	68ab      	ldr	r3, [r5, #8]
 80008a4:	ea23 0707 	bic.w	r7, r3, r7
 80008a8:	60af      	str	r7, [r5, #8]
        
        /* Clear EXTI line configuration */
        CLEAR_BIT(EXTI->IMR, (uint32_t)iocurrent);
 80008aa:	6823      	ldr	r3, [r4, #0]
 80008ac:	4033      	ands	r3, r6
 80008ae:	6023      	str	r3, [r4, #0]
        CLEAR_BIT(EXTI->EMR, (uint32_t)iocurrent);
 80008b0:	6863      	ldr	r3, [r4, #4]
 80008b2:	4033      	ands	r3, r6
 80008b4:	6063      	str	r3, [r4, #4]
        
        /* Clear Rising Falling edge configuration */
        CLEAR_BIT(EXTI->RTSR, (uint32_t)iocurrent);
 80008b6:	68a3      	ldr	r3, [r4, #8]
 80008b8:	4033      	ands	r3, r6
 80008ba:	60a3      	str	r3, [r4, #8]
        CLEAR_BIT(EXTI->FTSR, (uint32_t)iocurrent);
 80008bc:	68e3      	ldr	r3, [r4, #12]
 80008be:	401e      	ands	r6, r3
 80008c0:	60e6      	str	r6, [r4, #12]
      }
    }
    
    position++;
 80008c2:	3201      	adds	r2, #1
 80008c4:	e780      	b.n	80007c8 <HAL_GPIO_DeInit+0x14>
  }
}
 80008c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80008ca:	bf00      	nop
 80008cc:	40010400 	.word	0x40010400
 80008d0:	40020000 	.word	0x40020000
 80008d4:	40021400 	.word	0x40021400
 80008d8:	40021800 	.word	0x40021800

080008dc <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 80008dc:	b902      	cbnz	r2, 80008e0 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16 ;
 80008de:	0409      	lsls	r1, r1, #16
 80008e0:	6181      	str	r1, [r0, #24]
 80008e2:	4770      	bx	lr

080008e4 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  This function handles EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 80008e4:	b508      	push	{r3, lr}
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET) 
 80008e6:	4b04      	ldr	r3, [pc, #16]	; (80008f8 <HAL_GPIO_EXTI_IRQHandler+0x14>)
 80008e8:	6959      	ldr	r1, [r3, #20]
 80008ea:	4201      	tst	r1, r0
 80008ec:	d002      	beq.n	80008f4 <HAL_GPIO_EXTI_IRQHandler+0x10>
  { 
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 80008ee:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 80008f0:	f001 fafe 	bl	8001ef0 <HAL_GPIO_EXTI_Callback>
 80008f4:	bd08      	pop	{r3, pc}
 80008f6:	bf00      	nop
 80008f8:	40010400 	.word	0x40010400

080008fc <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.   
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1, PWR_REGULATOR_VOLTAGE_SCALE2 or PWR_REGULATOR_VOLTAGE_SCALE3)
  */  
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return  (PWR->CR & PWR_CR_VOS);
 80008fc:	4b02      	ldr	r3, [pc, #8]	; (8000908 <HAL_PWREx_GetVoltageRange+0xc>)
 80008fe:	6818      	ldr	r0, [r3, #0]
}
 8000900:	f400 50c0 	and.w	r0, r0, #6144	; 0x1800
 8000904:	4770      	bx	lr
 8000906:	bf00      	nop
 8000908:	40007000 	.word	0x40007000

0800090c <RCC_SetFlashLatencyFromMSIRange>:
            voltage range
  * @param  MSIrange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_6
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSIrange)
{
 800090c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  /* HCLK can reach 4 MHz only if AHB prescaler = 1 */
  if (READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
 800090e:	4c1a      	ldr	r4, [pc, #104]	; (8000978 <RCC_SetFlashLatencyFromMSIRange+0x6c>)
            voltage range
  * @param  MSIrange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_6
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSIrange)
{
 8000910:	4605      	mov	r5, r0
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  /* HCLK can reach 4 MHz only if AHB prescaler = 1 */
  if (READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
 8000912:	68a3      	ldr	r3, [r4, #8]
 8000914:	f013 0ff0 	tst.w	r3, #240	; 0xf0
 8000918:	d11a      	bne.n	8000950 <RCC_SetFlashLatencyFromMSIRange+0x44>
  {
    if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 800091a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800091c:	00db      	lsls	r3, r3, #3
 800091e:	d502      	bpl.n	8000926 <RCC_SetFlashLatencyFromMSIRange+0x1a>
    {
      vos = HAL_PWREx_GetVoltageRange();
 8000920:	f7ff ffec 	bl	80008fc <HAL_PWREx_GetVoltageRange>
 8000924:	e00e      	b.n	8000944 <RCC_SetFlashLatencyFromMSIRange+0x38>
    }
    else
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8000926:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000928:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800092c:	6263      	str	r3, [r4, #36]	; 0x24
 800092e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000930:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000934:	9301      	str	r3, [sp, #4]
 8000936:	9b01      	ldr	r3, [sp, #4]
      vos = HAL_PWREx_GetVoltageRange();
 8000938:	f7ff ffe0 	bl	80008fc <HAL_PWREx_GetVoltageRange>
      __HAL_RCC_PWR_CLK_DISABLE();
 800093c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800093e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8000942:	6263      	str	r3, [r4, #36]	; 0x24
    }
    
    /* Check if need to set latency 1 only for Range 3 & HCLK = 4MHz */
    if((vos == PWR_REGULATOR_VOLTAGE_SCALE3) && (MSIrange == RCC_MSIRANGE_6))
 8000944:	f5b0 5fc0 	cmp.w	r0, #6144	; 0x1800
 8000948:	d102      	bne.n	8000950 <RCC_SetFlashLatencyFromMSIRange+0x44>
 800094a:	f5b5 4f40 	cmp.w	r5, #49152	; 0xc000
 800094e:	d001      	beq.n	8000954 <RCC_SetFlashLatencyFromMSIRange+0x48>
            voltage range
  * @param  MSIrange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_6
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSIrange)
{
 8000950:	2300      	movs	r3, #0
 8000952:	e005      	b.n	8000960 <RCC_SetFlashLatencyFromMSIRange+0x54>
    {
      latency = FLASH_LATENCY_1; /* 1WS */
    }
  }
  
  __HAL_FLASH_SET_LATENCY(latency);
 8000954:	4a09      	ldr	r2, [pc, #36]	; (800097c <RCC_SetFlashLatencyFromMSIRange+0x70>)
 8000956:	6813      	ldr	r3, [r2, #0]
 8000958:	f043 0304 	orr.w	r3, r3, #4
 800095c:	6013      	str	r3, [r2, #0]
    }
    
    /* Check if need to set latency 1 only for Range 3 & HCLK = 4MHz */
    if((vos == PWR_REGULATOR_VOLTAGE_SCALE3) && (MSIrange == RCC_MSIRANGE_6))
    {
      latency = FLASH_LATENCY_1; /* 1WS */
 800095e:	2301      	movs	r3, #1
    }
  }
  
  __HAL_FLASH_SET_LATENCY(latency);
 8000960:	4906      	ldr	r1, [pc, #24]	; (800097c <RCC_SetFlashLatencyFromMSIRange+0x70>)
 8000962:	680a      	ldr	r2, [r1, #0]
 8000964:	f022 0201 	bic.w	r2, r2, #1
 8000968:	431a      	orrs	r2, r3
 800096a:	600a      	str	r2, [r1, #0]
  
  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
 800096c:	6808      	ldr	r0, [r1, #0]
 800096e:	f000 0001 	and.w	r0, r0, #1
 8000972:	4058      	eors	r0, r3
  {
    return HAL_ERROR;
  }
  
  return HAL_OK;
}
 8000974:	b003      	add	sp, #12
 8000976:	bd30      	pop	{r4, r5, pc}
 8000978:	40023800 	.word	0x40023800
 800097c:	40023c00 	.word	0x40023c00

08000980 <HAL_RCC_OscConfig>:
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000980:	6803      	ldr	r3, [r0, #0]
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8000982:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000986:	07dd      	lsls	r5, r3, #31
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8000988:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800098a:	d403      	bmi.n	8000994 <HAL_RCC_OscConfig+0x14>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800098c:	6823      	ldr	r3, [r4, #0]
 800098e:	0798      	lsls	r0, r3, #30
 8000990:	d474      	bmi.n	8000a7c <HAL_RCC_OscConfig+0xfc>
 8000992:	e0fb      	b.n	8000b8c <HAL_RCC_OscConfig+0x20c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 8000994:	4bb8      	ldr	r3, [pc, #736]	; (8000c78 <HAL_RCC_OscConfig+0x2f8>)
 8000996:	689a      	ldr	r2, [r3, #8]
 8000998:	f002 020c 	and.w	r2, r2, #12
 800099c:	2a08      	cmp	r2, #8
 800099e:	d007      	beq.n	80009b0 <HAL_RCC_OscConfig+0x30>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 80009a0:	689a      	ldr	r2, [r3, #8]
 80009a2:	f002 020c 	and.w	r2, r2, #12
 80009a6:	2a0c      	cmp	r2, #12
 80009a8:	d117      	bne.n	80009da <HAL_RCC_OscConfig+0x5a>
 80009aa:	689b      	ldr	r3, [r3, #8]
 80009ac:	03d9      	lsls	r1, r3, #15
 80009ae:	d514      	bpl.n	80009da <HAL_RCC_OscConfig+0x5a>
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80009b0:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 80009b4:	fa93 f2a3 	rbit	r2, r3
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80009b8:	4aaf      	ldr	r2, [pc, #700]	; (8000c78 <HAL_RCC_OscConfig+0x2f8>)
 80009ba:	6812      	ldr	r2, [r2, #0]
 80009bc:	fa93 f3a3 	rbit	r3, r3
 80009c0:	fab3 f383 	clz	r3, r3
 80009c4:	f003 031f 	and.w	r3, r3, #31
 80009c8:	fa22 f303 	lsr.w	r3, r2, r3
 80009cc:	07da      	lsls	r2, r3, #31
 80009ce:	d5dd      	bpl.n	800098c <HAL_RCC_OscConfig+0xc>
 80009d0:	6863      	ldr	r3, [r4, #4]
 80009d2:	2b00      	cmp	r3, #0
 80009d4:	d1da      	bne.n	800098c <HAL_RCC_OscConfig+0xc>
      {
        return HAL_ERROR;
 80009d6:	2001      	movs	r0, #1
 80009d8:	e30c      	b.n	8000ff4 <HAL_RCC_OscConfig+0x674>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80009da:	6863      	ldr	r3, [r4, #4]
 80009dc:	4da6      	ldr	r5, [pc, #664]	; (8000c78 <HAL_RCC_OscConfig+0x2f8>)
 80009de:	2b01      	cmp	r3, #1
 80009e0:	d014      	beq.n	8000a0c <HAL_RCC_OscConfig+0x8c>
 80009e2:	b96b      	cbnz	r3, 8000a00 <HAL_RCC_OscConfig+0x80>
 80009e4:	682b      	ldr	r3, [r5, #0]
 80009e6:	f44f 3600 	mov.w	r6, #131072	; 0x20000
 80009ea:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80009ee:	602b      	str	r3, [r5, #0]
 80009f0:	682b      	ldr	r3, [r5, #0]
 80009f2:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80009f6:	602b      	str	r3, [r5, #0]
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80009f8:	f7ff fc82 	bl	8000300 <HAL_GetTick>
 80009fc:	4607      	mov	r7, r0
        
        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80009fe:	e02f      	b.n	8000a60 <HAL_RCC_OscConfig+0xe0>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000a00:	2b05      	cmp	r3, #5
 8000a02:	682b      	ldr	r3, [r5, #0]
 8000a04:	d106      	bne.n	8000a14 <HAL_RCC_OscConfig+0x94>
 8000a06:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000a0a:	602b      	str	r3, [r5, #0]
 8000a0c:	682b      	ldr	r3, [r5, #0]
 8000a0e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000a12:	e005      	b.n	8000a20 <HAL_RCC_OscConfig+0xa0>
 8000a14:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000a18:	602b      	str	r3, [r5, #0]
 8000a1a:	682b      	ldr	r3, [r5, #0]
 8000a1c:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8000a20:	602b      	str	r3, [r5, #0]

       /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000a22:	f7ff fc6d 	bl	8000300 <HAL_GetTick>
 8000a26:	4607      	mov	r7, r0
        
        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000a28:	4e93      	ldr	r6, [pc, #588]	; (8000c78 <HAL_RCC_OscConfig+0x2f8>)
 8000a2a:	f44f 3500 	mov.w	r5, #131072	; 0x20000
 8000a2e:	fa95 f3a5 	rbit	r3, r5
 8000a32:	6832      	ldr	r2, [r6, #0]
 8000a34:	fa95 f3a5 	rbit	r3, r5
 8000a38:	fab3 f383 	clz	r3, r3
 8000a3c:	f003 031f 	and.w	r3, r3, #31
 8000a40:	fa22 f303 	lsr.w	r3, r2, r3
 8000a44:	07db      	lsls	r3, r3, #31
 8000a46:	d4a1      	bmi.n	800098c <HAL_RCC_OscConfig+0xc>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000a48:	f7ff fc5a 	bl	8000300 <HAL_GetTick>
 8000a4c:	1bc0      	subs	r0, r0, r7
 8000a4e:	2864      	cmp	r0, #100	; 0x64
 8000a50:	d9ed      	bls.n	8000a2e <HAL_RCC_OscConfig+0xae>
          {
            return HAL_TIMEOUT;
 8000a52:	2003      	movs	r0, #3
 8000a54:	e2ce      	b.n	8000ff4 <HAL_RCC_OscConfig+0x674>
        tickstart = HAL_GetTick();
        
        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000a56:	f7ff fc53 	bl	8000300 <HAL_GetTick>
 8000a5a:	1bc0      	subs	r0, r0, r7
 8000a5c:	2864      	cmp	r0, #100	; 0x64
 8000a5e:	d8f8      	bhi.n	8000a52 <HAL_RCC_OscConfig+0xd2>
 8000a60:	fa96 f3a6 	rbit	r3, r6
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
        
        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000a64:	682a      	ldr	r2, [r5, #0]
 8000a66:	fa96 f3a6 	rbit	r3, r6
 8000a6a:	fab3 f383 	clz	r3, r3
 8000a6e:	f003 031f 	and.w	r3, r3, #31
 8000a72:	fa22 f303 	lsr.w	r3, r2, r3
 8000a76:	07d8      	lsls	r0, r3, #31
 8000a78:	d4ed      	bmi.n	8000a56 <HAL_RCC_OscConfig+0xd6>
 8000a7a:	e787      	b.n	800098c <HAL_RCC_OscConfig+0xc>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 8000a7c:	4b7e      	ldr	r3, [pc, #504]	; (8000c78 <HAL_RCC_OscConfig+0x2f8>)
 8000a7e:	689a      	ldr	r2, [r3, #8]
 8000a80:	f002 020c 	and.w	r2, r2, #12
 8000a84:	2a04      	cmp	r2, #4
 8000a86:	d007      	beq.n	8000a98 <HAL_RCC_OscConfig+0x118>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 8000a88:	689a      	ldr	r2, [r3, #8]
 8000a8a:	f002 020c 	and.w	r2, r2, #12
 8000a8e:	2a0c      	cmp	r2, #12
 8000a90:	d125      	bne.n	8000ade <HAL_RCC_OscConfig+0x15e>
 8000a92:	689b      	ldr	r3, [r3, #8]
 8000a94:	03d9      	lsls	r1, r3, #15
 8000a96:	d422      	bmi.n	8000ade <HAL_RCC_OscConfig+0x15e>
 8000a98:	2302      	movs	r3, #2
 8000a9a:	fa93 f2a3 	rbit	r2, r3
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8000a9e:	4a76      	ldr	r2, [pc, #472]	; (8000c78 <HAL_RCC_OscConfig+0x2f8>)
 8000aa0:	6811      	ldr	r1, [r2, #0]
 8000aa2:	fa93 f3a3 	rbit	r3, r3
 8000aa6:	fab3 f383 	clz	r3, r3
 8000aaa:	f003 031f 	and.w	r3, r3, #31
 8000aae:	fa21 f303 	lsr.w	r3, r1, r3
 8000ab2:	f013 0f01 	tst.w	r3, #1
 8000ab6:	4613      	mov	r3, r2
 8000ab8:	d002      	beq.n	8000ac0 <HAL_RCC_OscConfig+0x140>
 8000aba:	68e2      	ldr	r2, [r4, #12]
 8000abc:	2a01      	cmp	r2, #1
 8000abe:	d18a      	bne.n	80009d6 <HAL_RCC_OscConfig+0x56>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000ac0:	685a      	ldr	r2, [r3, #4]
 8000ac2:	f44f 51f8 	mov.w	r1, #7936	; 0x1f00
 8000ac6:	fa91 f1a1 	rbit	r1, r1
 8000aca:	fab1 f181 	clz	r1, r1
 8000ace:	6920      	ldr	r0, [r4, #16]
 8000ad0:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
 8000ad4:	fa00 f101 	lsl.w	r1, r0, r1
 8000ad8:	430a      	orrs	r2, r1
 8000ada:	605a      	str	r2, [r3, #4]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8000adc:	e056      	b.n	8000b8c <HAL_RCC_OscConfig+0x20c>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8000ade:	68e2      	ldr	r2, [r4, #12]
 8000ae0:	2301      	movs	r3, #1
 8000ae2:	b38a      	cbz	r2, 8000b48 <HAL_RCC_OscConfig+0x1c8>
 8000ae4:	fa93 f2a3 	rbit	r2, r3
      {
       /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8000ae8:	fab2 f282 	clz	r2, r2
 8000aec:	0092      	lsls	r2, r2, #2
 8000aee:	f102 4284 	add.w	r2, r2, #1107296256	; 0x42000000
 8000af2:	f502 028e 	add.w	r2, r2, #4653056	; 0x470000
 8000af6:	6013      	str	r3, [r2, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000af8:	f7ff fc02 	bl	8000300 <HAL_GetTick>
 8000afc:	4607      	mov	r7, r0
        
        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000afe:	4e5e      	ldr	r6, [pc, #376]	; (8000c78 <HAL_RCC_OscConfig+0x2f8>)
 8000b00:	2502      	movs	r5, #2
 8000b02:	fa95 f3a5 	rbit	r3, r5
 8000b06:	485c      	ldr	r0, [pc, #368]	; (8000c78 <HAL_RCC_OscConfig+0x2f8>)
 8000b08:	6832      	ldr	r2, [r6, #0]
 8000b0a:	fa95 f3a5 	rbit	r3, r5
 8000b0e:	fab3 f383 	clz	r3, r3
 8000b12:	f003 031f 	and.w	r3, r3, #31
 8000b16:	fa22 f303 	lsr.w	r3, r2, r3
 8000b1a:	07da      	lsls	r2, r3, #31
 8000b1c:	d405      	bmi.n	8000b2a <HAL_RCC_OscConfig+0x1aa>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8000b1e:	f7ff fbef 	bl	8000300 <HAL_GetTick>
 8000b22:	1bc0      	subs	r0, r0, r7
 8000b24:	2802      	cmp	r0, #2
 8000b26:	d9ec      	bls.n	8000b02 <HAL_RCC_OscConfig+0x182>
 8000b28:	e793      	b.n	8000a52 <HAL_RCC_OscConfig+0xd2>
            return HAL_TIMEOUT;
          }
        }
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000b2a:	6843      	ldr	r3, [r0, #4]
 8000b2c:	f44f 52f8 	mov.w	r2, #7936	; 0x1f00
 8000b30:	fa92 f2a2 	rbit	r2, r2
 8000b34:	fab2 f282 	clz	r2, r2
 8000b38:	6921      	ldr	r1, [r4, #16]
 8000b3a:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 8000b3e:	fa01 f202 	lsl.w	r2, r1, r2
 8000b42:	4313      	orrs	r3, r2
 8000b44:	6043      	str	r3, [r0, #4]
 8000b46:	e021      	b.n	8000b8c <HAL_RCC_OscConfig+0x20c>
 8000b48:	fa93 f3a3 	rbit	r3, r3
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8000b4c:	fab3 f383 	clz	r3, r3
 8000b50:	009b      	lsls	r3, r3, #2
 8000b52:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8000b56:	f503 038e 	add.w	r3, r3, #4653056	; 0x470000
 8000b5a:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000b5c:	f7ff fbd0 	bl	8000300 <HAL_GetTick>
 8000b60:	4607      	mov	r7, r0
        
        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8000b62:	4e45      	ldr	r6, [pc, #276]	; (8000c78 <HAL_RCC_OscConfig+0x2f8>)
 8000b64:	2502      	movs	r5, #2
 8000b66:	fa95 f3a5 	rbit	r3, r5
 8000b6a:	6832      	ldr	r2, [r6, #0]
 8000b6c:	fa95 f3a5 	rbit	r3, r5
 8000b70:	fab3 f383 	clz	r3, r3
 8000b74:	f003 031f 	and.w	r3, r3, #31
 8000b78:	fa22 f303 	lsr.w	r3, r2, r3
 8000b7c:	07db      	lsls	r3, r3, #31
 8000b7e:	d505      	bpl.n	8000b8c <HAL_RCC_OscConfig+0x20c>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8000b80:	f7ff fbbe 	bl	8000300 <HAL_GetTick>
 8000b84:	1bc0      	subs	r0, r0, r7
 8000b86:	2802      	cmp	r0, #2
 8000b88:	d9ed      	bls.n	8000b66 <HAL_RCC_OscConfig+0x1e6>
 8000b8a:	e762      	b.n	8000a52 <HAL_RCC_OscConfig+0xd2>
        }
      }
    }
  }
  /*----------------------------- MSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8000b8c:	6823      	ldr	r3, [r4, #0]
 8000b8e:	06d8      	lsls	r0, r3, #27
 8000b90:	f140 80d8 	bpl.w	8000d44 <HAL_RCC_OscConfig+0x3c4>
  {
    /* When the MSI is used as system clock it will not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) )
 8000b94:	4d38      	ldr	r5, [pc, #224]	; (8000c78 <HAL_RCC_OscConfig+0x2f8>)
 8000b96:	68ab      	ldr	r3, [r5, #8]
 8000b98:	f013 0f0c 	tst.w	r3, #12
 8000b9c:	d172      	bne.n	8000c84 <HAL_RCC_OscConfig+0x304>
 8000b9e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000ba2:	fa93 f2a3 	rbit	r2, r3
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8000ba6:	682a      	ldr	r2, [r5, #0]
 8000ba8:	fa93 f3a3 	rbit	r3, r3
 8000bac:	fab3 f383 	clz	r3, r3
 8000bb0:	f003 031f 	and.w	r3, r3, #31
 8000bb4:	fa22 f303 	lsr.w	r3, r2, r3
 8000bb8:	07d9      	lsls	r1, r3, #31
 8000bba:	d503      	bpl.n	8000bc4 <HAL_RCC_OscConfig+0x244>
 8000bbc:	69a3      	ldr	r3, [r4, #24]
 8000bbe:	2b00      	cmp	r3, #0
 8000bc0:	f43f af09 	beq.w	80009d6 <HAL_RCC_OscConfig+0x56>
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device. */
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8000bc4:	4d2c      	ldr	r5, [pc, #176]	; (8000c78 <HAL_RCC_OscConfig+0x2f8>)
 8000bc6:	6a20      	ldr	r0, [r4, #32]
 8000bc8:	686b      	ldr	r3, [r5, #4]
 8000bca:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8000bce:	4298      	cmp	r0, r3
 8000bd0:	d919      	bls.n	8000c06 <HAL_RCC_OscConfig+0x286>
        {
          /* First increase number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8000bd2:	f7ff fe9b 	bl	800090c <RCC_SetFlashLatencyFromMSIRange>
 8000bd6:	2800      	cmp	r0, #0
 8000bd8:	f47f aefd 	bne.w	80009d6 <HAL_RCC_OscConfig+0x56>
          {
            return HAL_ERROR;
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8000bdc:	686b      	ldr	r3, [r5, #4]
 8000bde:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 8000be2:	6a23      	ldr	r3, [r4, #32]
 8000be4:	4313      	orrs	r3, r2
 8000be6:	606b      	str	r3, [r5, #4]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8000be8:	686b      	ldr	r3, [r5, #4]
 8000bea:	f04f 427f 	mov.w	r2, #4278190080	; 0xff000000
 8000bee:	fa92 f2a2 	rbit	r2, r2
 8000bf2:	fab2 f282 	clz	r2, r2
 8000bf6:	69e1      	ldr	r1, [r4, #28]
 8000bf8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8000bfc:	fa01 f202 	lsl.w	r2, r1, r2
 8000c00:	4313      	orrs	r3, r2
 8000c02:	606b      	str	r3, [r5, #4]
 8000c04:	e017      	b.n	8000c36 <HAL_RCC_OscConfig+0x2b6>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8000c06:	686b      	ldr	r3, [r5, #4]
 8000c08:	f04f 427f 	mov.w	r2, #4278190080	; 0xff000000
 8000c0c:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8000c10:	4303      	orrs	r3, r0
 8000c12:	606b      	str	r3, [r5, #4]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8000c14:	686b      	ldr	r3, [r5, #4]
 8000c16:	fa92 f2a2 	rbit	r2, r2
 8000c1a:	fab2 f282 	clz	r2, r2
 8000c1e:	69e1      	ldr	r1, [r4, #28]
 8000c20:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8000c24:	fa01 f202 	lsl.w	r2, r1, r2
 8000c28:	4313      	orrs	r3, r2
 8000c2a:	606b      	str	r3, [r5, #4]

          /* Decrease number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8000c2c:	f7ff fe6e 	bl	800090c <RCC_SetFlashLatencyFromMSIRange>
 8000c30:	2800      	cmp	r0, #0
 8000c32:	f47f aed0 	bne.w	80009d6 <HAL_RCC_OscConfig+0x56>
 8000c36:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 8000c3a:	fa93 f3a3 	rbit	r3, r3
            return HAL_ERROR;
          }          
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1U << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_BITNUMBER) + 1U))) 
 8000c3e:	fab3 f583 	clz	r5, r3
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_BITNUMBER)];
 8000c42:	4b0d      	ldr	r3, [pc, #52]	; (8000c78 <HAL_RCC_OscConfig+0x2f8>)
 8000c44:	22f0      	movs	r2, #240	; 0xf0
 8000c46:	6899      	ldr	r1, [r3, #8]
 8000c48:	fa92 f2a2 	rbit	r2, r2
 8000c4c:	fab2 f082 	clz	r0, r2
            return HAL_ERROR;
          }          
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1U << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_BITNUMBER) + 1U))) 
 8000c50:	6a23      	ldr	r3, [r4, #32]
 8000c52:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8000c56:	40eb      	lsrs	r3, r5
 8000c58:	3301      	adds	r3, #1
 8000c5a:	fa02 f303 	lsl.w	r3, r2, r3
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_BITNUMBER)];
 8000c5e:	f001 02f0 	and.w	r2, r1, #240	; 0xf0
            return HAL_ERROR;
          }          
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1U << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_BITNUMBER) + 1U))) 
 8000c62:	4906      	ldr	r1, [pc, #24]	; (8000c7c <HAL_RCC_OscConfig+0x2fc>)
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_BITNUMBER)];
 8000c64:	40c2      	lsrs	r2, r0
            return HAL_ERROR;
          }          
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1U << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_BITNUMBER) + 1U))) 
 8000c66:	5c8a      	ldrb	r2, [r1, r2]
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_BITNUMBER)];

        /* Configure the source of time base considering new system clocks settings*/
        HAL_InitTick (TICK_INT_PRIORITY);
 8000c68:	200f      	movs	r0, #15
            return HAL_ERROR;
          }          
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1U << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_BITNUMBER) + 1U))) 
 8000c6a:	40d3      	lsrs	r3, r2
 8000c6c:	4a04      	ldr	r2, [pc, #16]	; (8000c80 <HAL_RCC_OscConfig+0x300>)
 8000c6e:	6013      	str	r3, [r2, #0]
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_BITNUMBER)];

        /* Configure the source of time base considering new system clocks settings*/
        HAL_InitTick (TICK_INT_PRIORITY);
 8000c70:	f7ff fb14 	bl	800029c <HAL_InitTick>
 8000c74:	e066      	b.n	8000d44 <HAL_RCC_OscConfig+0x3c4>
 8000c76:	bf00      	nop
 8000c78:	40023800 	.word	0x40023800
 8000c7c:	08002204 	.word	0x08002204
 8000c80:	20000008 	.word	0x20000008
    {
      /* Check MSI State */
      assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));

      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8000c84:	69a2      	ldr	r2, [r4, #24]
 8000c86:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000c8a:	2a00      	cmp	r2, #0
 8000c8c:	d038      	beq.n	8000d00 <HAL_RCC_OscConfig+0x380>
 8000c8e:	fa93 f3a3 	rbit	r3, r3
      {
        /* Enable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 8000c92:	fab3 f383 	clz	r3, r3
 8000c96:	009b      	lsls	r3, r3, #2
 8000c98:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8000c9c:	f503 038e 	add.w	r3, r3, #4653056	; 0x470000
 8000ca0:	2201      	movs	r2, #1
 8000ca2:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000ca4:	f7ff fb2c 	bl	8000300 <HAL_GetTick>
 8000ca8:	4607      	mov	r7, r0
 8000caa:	f44f 7600 	mov.w	r6, #512	; 0x200
 8000cae:	fa96 f3a6 	rbit	r3, r6

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 8000cb2:	49bb      	ldr	r1, [pc, #748]	; (8000fa0 <HAL_RCC_OscConfig+0x620>)
 8000cb4:	682a      	ldr	r2, [r5, #0]
 8000cb6:	fa96 f3a6 	rbit	r3, r6
 8000cba:	fab3 f383 	clz	r3, r3
 8000cbe:	f003 031f 	and.w	r3, r3, #31
 8000cc2:	fa22 f303 	lsr.w	r3, r2, r3
 8000cc6:	07da      	lsls	r2, r3, #31
 8000cc8:	d405      	bmi.n	8000cd6 <HAL_RCC_OscConfig+0x356>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8000cca:	f7ff fb19 	bl	8000300 <HAL_GetTick>
 8000cce:	1bc0      	subs	r0, r0, r7
 8000cd0:	2802      	cmp	r0, #2
 8000cd2:	d9ec      	bls.n	8000cae <HAL_RCC_OscConfig+0x32e>
 8000cd4:	e6bd      	b.n	8000a52 <HAL_RCC_OscConfig+0xd2>
        /* Check MSICalibrationValue and MSIClockRange input parameters */
        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8000cd6:	684b      	ldr	r3, [r1, #4]
 8000cd8:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 8000cdc:	6a23      	ldr	r3, [r4, #32]
 8000cde:	4313      	orrs	r3, r2
 8000ce0:	604b      	str	r3, [r1, #4]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8000ce2:	684b      	ldr	r3, [r1, #4]
 8000ce4:	f04f 427f 	mov.w	r2, #4278190080	; 0xff000000
 8000ce8:	fa92 f2a2 	rbit	r2, r2
 8000cec:	fab2 f282 	clz	r2, r2
 8000cf0:	69e0      	ldr	r0, [r4, #28]
 8000cf2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8000cf6:	fa00 f202 	lsl.w	r2, r0, r2
 8000cfa:	4313      	orrs	r3, r2
 8000cfc:	604b      	str	r3, [r1, #4]
 8000cfe:	e021      	b.n	8000d44 <HAL_RCC_OscConfig+0x3c4>
 8000d00:	fa93 f3a3 	rbit	r3, r3

      }
      else
      {
        /* Disable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 8000d04:	fab3 f383 	clz	r3, r3
 8000d08:	009b      	lsls	r3, r3, #2
 8000d0a:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8000d0e:	f503 038e 	add.w	r3, r3, #4653056	; 0x470000
 8000d12:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000d14:	f7ff faf4 	bl	8000300 <HAL_GetTick>
 8000d18:	4607      	mov	r7, r0
 8000d1a:	f44f 7600 	mov.w	r6, #512	; 0x200
 8000d1e:	fa96 f3a6 	rbit	r3, r6

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET)
 8000d22:	682a      	ldr	r2, [r5, #0]
 8000d24:	fa96 f3a6 	rbit	r3, r6
 8000d28:	fab3 f383 	clz	r3, r3
 8000d2c:	f003 031f 	and.w	r3, r3, #31
 8000d30:	fa22 f303 	lsr.w	r3, r2, r3
 8000d34:	07db      	lsls	r3, r3, #31
 8000d36:	d505      	bpl.n	8000d44 <HAL_RCC_OscConfig+0x3c4>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8000d38:	f7ff fae2 	bl	8000300 <HAL_GetTick>
 8000d3c:	1bc0      	subs	r0, r0, r7
 8000d3e:	2802      	cmp	r0, #2
 8000d40:	d9ed      	bls.n	8000d1e <HAL_RCC_OscConfig+0x39e>
 8000d42:	e686      	b.n	8000a52 <HAL_RCC_OscConfig+0xd2>
        }
      }
    }
  }  
  /*------------------------------ LSI Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8000d44:	6823      	ldr	r3, [r4, #0]
 8000d46:	0718      	lsls	r0, r3, #28
 8000d48:	d403      	bmi.n	8000d52 <HAL_RCC_OscConfig+0x3d2>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8000d4a:	6823      	ldr	r3, [r4, #0]
 8000d4c:	0759      	lsls	r1, r3, #29
 8000d4e:	d440      	bmi.n	8000dd2 <HAL_RCC_OscConfig+0x452>
 8000d50:	e0c2      	b.n	8000ed8 <HAL_RCC_OscConfig+0x558>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    
    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8000d52:	6962      	ldr	r2, [r4, #20]
 8000d54:	2301      	movs	r3, #1
 8000d56:	4993      	ldr	r1, [pc, #588]	; (8000fa4 <HAL_RCC_OscConfig+0x624>)
 8000d58:	b1ea      	cbz	r2, 8000d96 <HAL_RCC_OscConfig+0x416>
 8000d5a:	fa93 f2a3 	rbit	r2, r3
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8000d5e:	fab2 f282 	clz	r2, r2
 8000d62:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000d66:	f7ff facb 	bl	8000300 <HAL_GetTick>
 8000d6a:	4607      	mov	r7, r0
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8000d6c:	4e8c      	ldr	r6, [pc, #560]	; (8000fa0 <HAL_RCC_OscConfig+0x620>)
 8000d6e:	2502      	movs	r5, #2
 8000d70:	fa95 f3a5 	rbit	r3, r5
 8000d74:	6b72      	ldr	r2, [r6, #52]	; 0x34
 8000d76:	fa95 f3a5 	rbit	r3, r5
 8000d7a:	fab3 f383 	clz	r3, r3
 8000d7e:	f003 031f 	and.w	r3, r3, #31
 8000d82:	fa22 f303 	lsr.w	r3, r2, r3
 8000d86:	07da      	lsls	r2, r3, #31
 8000d88:	d4df      	bmi.n	8000d4a <HAL_RCC_OscConfig+0x3ca>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8000d8a:	f7ff fab9 	bl	8000300 <HAL_GetTick>
 8000d8e:	1bc0      	subs	r0, r0, r7
 8000d90:	2802      	cmp	r0, #2
 8000d92:	d9ed      	bls.n	8000d70 <HAL_RCC_OscConfig+0x3f0>
 8000d94:	e65d      	b.n	8000a52 <HAL_RCC_OscConfig+0xd2>
 8000d96:	fa93 f3a3 	rbit	r3, r3
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8000d9a:	fab3 f383 	clz	r3, r3
 8000d9e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000da2:	f7ff faad 	bl	8000300 <HAL_GetTick>
 8000da6:	4607      	mov	r7, r0
      
      /* Wait till LSI is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8000da8:	4e7d      	ldr	r6, [pc, #500]	; (8000fa0 <HAL_RCC_OscConfig+0x620>)
 8000daa:	2502      	movs	r5, #2
 8000dac:	fa95 f3a5 	rbit	r3, r5
 8000db0:	6b72      	ldr	r2, [r6, #52]	; 0x34
 8000db2:	fa95 f3a5 	rbit	r3, r5
 8000db6:	fab3 f383 	clz	r3, r3
 8000dba:	f003 031f 	and.w	r3, r3, #31
 8000dbe:	fa22 f303 	lsr.w	r3, r2, r3
 8000dc2:	07db      	lsls	r3, r3, #31
 8000dc4:	d5c1      	bpl.n	8000d4a <HAL_RCC_OscConfig+0x3ca>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8000dc6:	f7ff fa9b 	bl	8000300 <HAL_GetTick>
 8000dca:	1bc0      	subs	r0, r0, r7
 8000dcc:	2802      	cmp	r0, #2
 8000dce:	d9ed      	bls.n	8000dac <HAL_RCC_OscConfig+0x42c>
 8000dd0:	e63f      	b.n	8000a52 <HAL_RCC_OscConfig+0xd2>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000dd2:	4b73      	ldr	r3, [pc, #460]	; (8000fa0 <HAL_RCC_OscConfig+0x620>)
 8000dd4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000dd6:	00d0      	lsls	r0, r2, #3
 8000dd8:	d40a      	bmi.n	8000df0 <HAL_RCC_OscConfig+0x470>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8000dda:	6a5a      	ldr	r2, [r3, #36]	; 0x24
      pwrclkchanged = SET;
 8000ddc:	2601      	movs	r6, #1

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8000dde:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000de2:	625a      	str	r2, [r3, #36]	; 0x24
 8000de4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000de6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000dea:	9301      	str	r3, [sp, #4]
 8000dec:	9b01      	ldr	r3, [sp, #4]
 8000dee:	e000      	b.n	8000df2 <HAL_RCC_OscConfig+0x472>
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
  {
    FlagStatus       pwrclkchanged = RESET;
 8000df0:	2600      	movs	r6, #0
    {
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000df2:	4d6d      	ldr	r5, [pc, #436]	; (8000fa8 <HAL_RCC_OscConfig+0x628>)
 8000df4:	682b      	ldr	r3, [r5, #0]
 8000df6:	05d9      	lsls	r1, r3, #23
 8000df8:	d504      	bpl.n	8000e04 <HAL_RCC_OscConfig+0x484>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000dfa:	68a3      	ldr	r3, [r4, #8]
 8000dfc:	4d68      	ldr	r5, [pc, #416]	; (8000fa0 <HAL_RCC_OscConfig+0x620>)
 8000dfe:	2b01      	cmp	r3, #1
 8000e00:	d110      	bne.n	8000e24 <HAL_RCC_OscConfig+0x4a4>
 8000e02:	e026      	b.n	8000e52 <HAL_RCC_OscConfig+0x4d2>
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8000e04:	682b      	ldr	r3, [r5, #0]
 8000e06:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000e0a:	602b      	str	r3, [r5, #0]
      
      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8000e0c:	f7ff fa78 	bl	8000300 <HAL_GetTick>
 8000e10:	4607      	mov	r7, r0

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000e12:	682b      	ldr	r3, [r5, #0]
 8000e14:	05da      	lsls	r2, r3, #23
 8000e16:	d4f0      	bmi.n	8000dfa <HAL_RCC_OscConfig+0x47a>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8000e18:	f7ff fa72 	bl	8000300 <HAL_GetTick>
 8000e1c:	1bc0      	subs	r0, r0, r7
 8000e1e:	2864      	cmp	r0, #100	; 0x64
 8000e20:	d9f7      	bls.n	8000e12 <HAL_RCC_OscConfig+0x492>
 8000e22:	e616      	b.n	8000a52 <HAL_RCC_OscConfig+0xd2>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000e24:	b97b      	cbnz	r3, 8000e46 <HAL_RCC_OscConfig+0x4c6>
 8000e26:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000e28:	f44f 7700 	mov.w	r7, #512	; 0x200
 8000e2c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000e30:	636b      	str	r3, [r5, #52]	; 0x34
 8000e32:	6b6b      	ldr	r3, [r5, #52]	; 0x34
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000e34:	f241 3988 	movw	r9, #5000	; 0x1388
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000e38:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000e3c:	636b      	str	r3, [r5, #52]	; 0x34
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000e3e:	f7ff fa5f 	bl	8000300 <HAL_GetTick>
 8000e42:	4680      	mov	r8, r0
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000e44:	e035      	b.n	8000eb2 <HAL_RCC_OscConfig+0x532>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000e46:	2b05      	cmp	r3, #5
 8000e48:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000e4a:	d106      	bne.n	8000e5a <HAL_RCC_OscConfig+0x4da>
 8000e4c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000e50:	636b      	str	r3, [r5, #52]	; 0x34
 8000e52:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000e54:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000e58:	e005      	b.n	8000e66 <HAL_RCC_OscConfig+0x4e6>
 8000e5a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000e5e:	636b      	str	r3, [r5, #52]	; 0x34
 8000e60:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000e62:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000e66:	636b      	str	r3, [r5, #52]	; 0x34
    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000e68:	f7ff fa4a 	bl	8000300 <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000e6c:	f241 3788 	movw	r7, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000e70:	4681      	mov	r9, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000e72:	f8df 812c 	ldr.w	r8, [pc, #300]	; 8000fa0 <HAL_RCC_OscConfig+0x620>
 8000e76:	f44f 7500 	mov.w	r5, #512	; 0x200
 8000e7a:	fa95 f3a5 	rbit	r3, r5
 8000e7e:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
 8000e82:	fa95 f3a5 	rbit	r3, r5
 8000e86:	fab3 f383 	clz	r3, r3
 8000e8a:	f003 031f 	and.w	r3, r3, #31
 8000e8e:	fa22 f303 	lsr.w	r3, r2, r3
 8000e92:	07db      	lsls	r3, r3, #31
 8000e94:	d41a      	bmi.n	8000ecc <HAL_RCC_OscConfig+0x54c>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000e96:	f7ff fa33 	bl	8000300 <HAL_GetTick>
 8000e9a:	ebc9 0000 	rsb	r0, r9, r0
 8000e9e:	42b8      	cmp	r0, r7
 8000ea0:	d9eb      	bls.n	8000e7a <HAL_RCC_OscConfig+0x4fa>
 8000ea2:	e5d6      	b.n	8000a52 <HAL_RCC_OscConfig+0xd2>
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000ea4:	f7ff fa2c 	bl	8000300 <HAL_GetTick>
 8000ea8:	ebc8 0000 	rsb	r0, r8, r0
 8000eac:	4548      	cmp	r0, r9
 8000eae:	f63f add0 	bhi.w	8000a52 <HAL_RCC_OscConfig+0xd2>
 8000eb2:	fa97 f3a7 	rbit	r3, r7
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000eb6:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8000eb8:	fa97 f3a7 	rbit	r3, r7
 8000ebc:	fab3 f383 	clz	r3, r3
 8000ec0:	f003 031f 	and.w	r3, r3, #31
 8000ec4:	fa22 f303 	lsr.w	r3, r2, r3
 8000ec8:	07d8      	lsls	r0, r3, #31
 8000eca:	d4eb      	bmi.n	8000ea4 <HAL_RCC_OscConfig+0x524>
        }
      }
    }

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 8000ecc:	b126      	cbz	r6, 8000ed8 <HAL_RCC_OscConfig+0x558>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8000ece:	4a34      	ldr	r2, [pc, #208]	; (8000fa0 <HAL_RCC_OscConfig+0x620>)
 8000ed0:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8000ed2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8000ed6:	6253      	str	r3, [r2, #36]	; 0x24
  }

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8000ed8:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8000eda:	b90a      	cbnz	r2, 8000ee0 <HAL_RCC_OscConfig+0x560>
    {
      return HAL_ERROR;
    }
  }
  
  return HAL_OK;
 8000edc:	2000      	movs	r0, #0
 8000ede:	e089      	b.n	8000ff4 <HAL_RCC_OscConfig+0x674>
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8000ee0:	4d2f      	ldr	r5, [pc, #188]	; (8000fa0 <HAL_RCC_OscConfig+0x620>)
 8000ee2:	68ab      	ldr	r3, [r5, #8]
 8000ee4:	f003 030c 	and.w	r3, r3, #12
 8000ee8:	2b0c      	cmp	r3, #12
 8000eea:	f43f ad74 	beq.w	80009d6 <HAL_RCC_OscConfig+0x56>
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8000eee:	2a02      	cmp	r2, #2
 8000ef0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8000ef4:	d15a      	bne.n	8000fac <HAL_RCC_OscConfig+0x62c>
 8000ef6:	fa93 f3a3 	rbit	r3, r3
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
        assert_param(IS_RCC_PLL_DIV(RCC_OscInitStruct->PLL.PLLDIV));
  
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8000efa:	fab3 f383 	clz	r3, r3
 8000efe:	009b      	lsls	r3, r3, #2
 8000f00:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8000f04:	f503 038e 	add.w	r3, r3, #4653056	; 0x470000
 8000f08:	2200      	movs	r2, #0
 8000f0a:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000f0c:	f7ff f9f8 	bl	8000300 <HAL_GetTick>
 8000f10:	4680      	mov	r8, r0
 8000f12:	f04f 7700 	mov.w	r7, #33554432	; 0x2000000
 8000f16:	fa97 f3a7 	rbit	r3, r7
        
        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000f1a:	4e21      	ldr	r6, [pc, #132]	; (8000fa0 <HAL_RCC_OscConfig+0x620>)
 8000f1c:	682a      	ldr	r2, [r5, #0]
 8000f1e:	fa97 f3a7 	rbit	r3, r7
 8000f22:	fab3 f383 	clz	r3, r3
 8000f26:	f003 031f 	and.w	r3, r3, #31
 8000f2a:	fa22 f303 	lsr.w	r3, r2, r3
 8000f2e:	07d9      	lsls	r1, r3, #31
 8000f30:	d506      	bpl.n	8000f40 <HAL_RCC_OscConfig+0x5c0>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000f32:	f7ff f9e5 	bl	8000300 <HAL_GetTick>
 8000f36:	ebc8 0000 	rsb	r0, r8, r0
 8000f3a:	2802      	cmp	r0, #2
 8000f3c:	d9eb      	bls.n	8000f16 <HAL_RCC_OscConfig+0x596>
 8000f3e:	e588      	b.n	8000a52 <HAL_RCC_OscConfig+0xd2>
            return HAL_TIMEOUT;
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8000f40:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000f42:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8000f44:	68b3      	ldr	r3, [r6, #8]
 8000f46:	4311      	orrs	r1, r2
 8000f48:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8000f4a:	f423 037d 	bic.w	r3, r3, #16580608	; 0xfd0000
 8000f4e:	430a      	orrs	r2, r1
 8000f50:	4313      	orrs	r3, r2
 8000f52:	60b3      	str	r3, [r6, #8]
 8000f54:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8000f58:	fa93 f3a3 	rbit	r3, r3
                             RCC_OscInitStruct->PLL.PLLMUL,
                             RCC_OscInitStruct->PLL.PLLDIV);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8000f5c:	fab3 f383 	clz	r3, r3
 8000f60:	009b      	lsls	r3, r3, #2
 8000f62:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8000f66:	f503 038e 	add.w	r3, r3, #4653056	; 0x470000
 8000f6a:	2201      	movs	r2, #1
 8000f6c:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000f6e:	f7ff f9c7 	bl	8000300 <HAL_GetTick>
 8000f72:	4605      	mov	r5, r0
 8000f74:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
 8000f78:	fa94 f3a4 	rbit	r3, r4
        
        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8000f7c:	6832      	ldr	r2, [r6, #0]
 8000f7e:	fa94 f3a4 	rbit	r3, r4
 8000f82:	fab3 f383 	clz	r3, r3
 8000f86:	f003 031f 	and.w	r3, r3, #31
 8000f8a:	fa22 f303 	lsr.w	r3, r2, r3
 8000f8e:	07da      	lsls	r2, r3, #31
 8000f90:	d4a4      	bmi.n	8000edc <HAL_RCC_OscConfig+0x55c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000f92:	f7ff f9b5 	bl	8000300 <HAL_GetTick>
 8000f96:	1b40      	subs	r0, r0, r5
 8000f98:	2802      	cmp	r0, #2
 8000f9a:	d9ed      	bls.n	8000f78 <HAL_RCC_OscConfig+0x5f8>
 8000f9c:	e559      	b.n	8000a52 <HAL_RCC_OscConfig+0xd2>
 8000f9e:	bf00      	nop
 8000fa0:	40023800 	.word	0x40023800
 8000fa4:	42470680 	.word	0x42470680
 8000fa8:	40007000 	.word	0x40007000
 8000fac:	fa93 f3a3 	rbit	r3, r3
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8000fb0:	fab3 f383 	clz	r3, r3
 8000fb4:	009b      	lsls	r3, r3, #2
 8000fb6:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8000fba:	f503 038e 	add.w	r3, r3, #4653056	; 0x470000
 8000fbe:	2200      	movs	r2, #0
 8000fc0:	601a      	str	r2, [r3, #0]
 
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000fc2:	f7ff f99d 	bl	8000300 <HAL_GetTick>
 8000fc6:	4606      	mov	r6, r0
 8000fc8:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
 8000fcc:	fa94 f3a4 	rbit	r3, r4
        
        /* Wait till PLL is disabled */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000fd0:	682a      	ldr	r2, [r5, #0]
 8000fd2:	fa94 f3a4 	rbit	r3, r4
 8000fd6:	fab3 f383 	clz	r3, r3
 8000fda:	f003 031f 	and.w	r3, r3, #31
 8000fde:	fa22 f303 	lsr.w	r3, r2, r3
 8000fe2:	07db      	lsls	r3, r3, #31
 8000fe4:	f57f af7a 	bpl.w	8000edc <HAL_RCC_OscConfig+0x55c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000fe8:	f7ff f98a 	bl	8000300 <HAL_GetTick>
 8000fec:	1b80      	subs	r0, r0, r6
 8000fee:	2802      	cmp	r0, #2
 8000ff0:	d9ec      	bls.n	8000fcc <HAL_RCC_OscConfig+0x64c>
 8000ff2:	e52e      	b.n	8000a52 <HAL_RCC_OscConfig+0xd2>
      return HAL_ERROR;
    }
  }
  
  return HAL_OK;
}
 8000ff4:	b003      	add	sp, #12
 8000ff6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8000ffa:	bf00      	nop

08000ffc <HAL_RCC_GetSysClockFreq>:
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t tmpreg = 0, pllm = 0, plld = 0, pllvco = 0, msiclkrange = 0;
  uint32_t sysclockfreq = 0;
  
  tmpreg = RCC->CFGR;
 8000ffc:	491e      	ldr	r1, [pc, #120]	; (8001078 <HAL_RCC_GetSysClockFreq+0x7c>)
 8000ffe:	688b      	ldr	r3, [r1, #8]
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 8001000:	f003 020c 	and.w	r2, r3, #12
 8001004:	2a08      	cmp	r2, #8
 8001006:	d014      	beq.n	8001032 <HAL_RCC_GetSysClockFreq+0x36>
 8001008:	2a0c      	cmp	r2, #12
 800100a:	d014      	beq.n	8001036 <HAL_RCC_GetSysClockFreq+0x3a>
 800100c:	2a04      	cmp	r2, #4
 800100e:	d031      	beq.n	8001074 <HAL_RCC_GetSysClockFreq+0x78>
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_MSI:  /* MSI used as system clock source */
    default: /* MSI used as system clock */
    {
      msiclkrange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> RCC_ICSCR_MSIRANGE_BITNUMBER;
 8001010:	684b      	ldr	r3, [r1, #4]
 8001012:	f44f 4060 	mov.w	r0, #57344	; 0xe000
 8001016:	fa90 f0a0 	rbit	r0, r0
 800101a:	fab0 f080 	clz	r0, r0
      sysclockfreq = (32768 * (1 << (msiclkrange + 1)));
 800101e:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8001022:	fa23 f000 	lsr.w	r0, r3, r0
 8001026:	3001      	adds	r0, #1
 8001028:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800102c:	fa03 f000 	lsl.w	r0, r3, r0
 8001030:	4770      	bx	lr
      sysclockfreq = HSI_VALUE;
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 8001032:	4812      	ldr	r0, [pc, #72]	; (800107c <HAL_RCC_GetSysClockFreq+0x80>)
 8001034:	4770      	bx	lr
 8001036:	f44f 1270 	mov.w	r2, #3932160	; 0x3c0000
 800103a:	fa92 f2a2 	rbit	r2, r2
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllm = PLLMulTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 800103e:	fab2 f282 	clz	r2, r2
 8001042:	f403 1070 	and.w	r0, r3, #3932160	; 0x3c0000
 8001046:	fa20 f202 	lsr.w	r2, r0, r2
 800104a:	480d      	ldr	r0, [pc, #52]	; (8001080 <HAL_RCC_GetSysClockFreq+0x84>)
 800104c:	5c80      	ldrb	r0, [r0, r2]
 800104e:	f44f 0240 	mov.w	r2, #12582912	; 0xc00000
 8001052:	fa92 f2a2 	rbit	r2, r2
      plld = ((uint32_t)(tmpreg & RCC_CFGR_PLLDIV) >> RCC_CFGR_PLLDIV_BITNUMBER) + 1;
 8001056:	fab2 f282 	clz	r2, r2
 800105a:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
 800105e:	40d3      	lsrs	r3, r2
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8001060:	688a      	ldr	r2, [r1, #8]
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllm = PLLMulTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
      plld = ((uint32_t)(tmpreg & RCC_CFGR_PLLDIV) >> RCC_CFGR_PLLDIV_BITNUMBER) + 1;
 8001062:	3301      	adds	r3, #1
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8001064:	03d2      	lsls	r2, r2, #15
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE * pllm) / plld;
 8001066:	bf4c      	ite	mi
 8001068:	4a04      	ldrmi	r2, [pc, #16]	; (800107c <HAL_RCC_GetSysClockFreq+0x80>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE * pllm) / plld;
 800106a:	4a06      	ldrpl	r2, [pc, #24]	; (8001084 <HAL_RCC_GetSysClockFreq+0x88>)
 800106c:	4350      	muls	r0, r2
 800106e:	fbb0 f0f3 	udiv	r0, r0, r3
 8001072:	4770      	bx	lr
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8001074:	4803      	ldr	r0, [pc, #12]	; (8001084 <HAL_RCC_GetSysClockFreq+0x88>)
      sysclockfreq = (32768 * (1 << (msiclkrange + 1)));
      break;
    }
  }
  return sysclockfreq;
}
 8001076:	4770      	bx	lr
 8001078:	40023800 	.word	0x40023800
 800107c:	007a1200 	.word	0x007a1200
 8001080:	0800221c 	.word	0x0800221c
 8001084:	00f42400 	.word	0x00f42400

08001088 <HAL_RCC_ClockConfig>:
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
  must be correctly programmed according to the frequency of the CPU clock 
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001088:	4b5f      	ldr	r3, [pc, #380]	; (8001208 <HAL_RCC_ClockConfig+0x180>)
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800108a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
  must be correctly programmed according to the frequency of the CPU clock 
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 800108e:	681a      	ldr	r2, [r3, #0]
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8001090:	4606      	mov	r6, r0
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
  must be correctly programmed according to the frequency of the CPU clock 
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001092:	f002 0201 	and.w	r2, r2, #1
 8001096:	428a      	cmp	r2, r1
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8001098:	460d      	mov	r5, r1
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
  must be correctly programmed according to the frequency of the CPU clock 
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 800109a:	d30a      	bcc.n	80010b2 <HAL_RCC_ClockConfig+0x2a>
      return HAL_ERROR;
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800109c:	6831      	ldr	r1, [r6, #0]
 800109e:	078b      	lsls	r3, r1, #30
 80010a0:	d51a      	bpl.n	80010d8 <HAL_RCC_ClockConfig+0x50>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80010a2:	485a      	ldr	r0, [pc, #360]	; (800120c <HAL_RCC_ClockConfig+0x184>)
 80010a4:	6883      	ldr	r3, [r0, #8]
 80010a6:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 80010aa:	68b3      	ldr	r3, [r6, #8]
 80010ac:	4313      	orrs	r3, r2
 80010ae:	6083      	str	r3, [r0, #8]
 80010b0:	e012      	b.n	80010d8 <HAL_RCC_ClockConfig+0x50>

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80010b2:	2901      	cmp	r1, #1
 80010b4:	bf02      	ittt	eq
 80010b6:	681a      	ldreq	r2, [r3, #0]
 80010b8:	f042 0204 	orreq.w	r2, r2, #4
 80010bc:	601a      	streq	r2, [r3, #0]
 80010be:	681a      	ldr	r2, [r3, #0]
 80010c0:	f022 0201 	bic.w	r2, r2, #1
 80010c4:	430a      	orrs	r2, r1
 80010c6:	601a      	str	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80010c8:	681b      	ldr	r3, [r3, #0]
 80010ca:	f003 0301 	and.w	r3, r3, #1
 80010ce:	4299      	cmp	r1, r3
 80010d0:	d0e4      	beq.n	800109c <HAL_RCC_ClockConfig+0x14>
    {
      return HAL_ERROR;
 80010d2:	2001      	movs	r0, #1
 80010d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80010d8:	07cf      	lsls	r7, r1, #31
 80010da:	d406      	bmi.n	80010ea <HAL_RCC_ClockConfig+0x62>
        }
      }
    }
  }    
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 80010dc:	4b4a      	ldr	r3, [pc, #296]	; (8001208 <HAL_RCC_ClockConfig+0x180>)
 80010de:	681a      	ldr	r2, [r3, #0]
 80010e0:	f002 0201 	and.w	r2, r2, #1
 80010e4:	4295      	cmp	r5, r2
 80010e6:	d35d      	bcc.n	80011a4 <HAL_RCC_ClockConfig+0x11c>
 80010e8:	e063      	b.n	80011b2 <HAL_RCC_ClockConfig+0x12a>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {    
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    
    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80010ea:	6872      	ldr	r2, [r6, #4]
 80010ec:	4947      	ldr	r1, [pc, #284]	; (800120c <HAL_RCC_ClockConfig+0x184>)
 80010ee:	2a02      	cmp	r2, #2
 80010f0:	d102      	bne.n	80010f8 <HAL_RCC_ClockConfig+0x70>
 80010f2:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 80010f6:	e009      	b.n	800110c <HAL_RCC_ClockConfig+0x84>
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80010f8:	2a03      	cmp	r2, #3
 80010fa:	d102      	bne.n	8001102 <HAL_RCC_ClockConfig+0x7a>
 80010fc:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8001100:	e004      	b.n	800110c <HAL_RCC_ClockConfig+0x84>
      {
        return HAL_ERROR;
      }
    }
    /* HSI is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 8001102:	2a01      	cmp	r2, #1
 8001104:	bf0c      	ite	eq
 8001106:	2302      	moveq	r3, #2
 8001108:	f44f 7300 	movne.w	r3, #512	; 0x200
 800110c:	fa93 f0a3 	rbit	r0, r3
    }
    /* MSI is selected as System Clock Source */
    else
    {
      /* Check the MSI ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 8001110:	6809      	ldr	r1, [r1, #0]
 8001112:	fa93 f3a3 	rbit	r3, r3
 8001116:	fab3 f383 	clz	r3, r3
 800111a:	f003 031f 	and.w	r3, r3, #31
 800111e:	fa21 f303 	lsr.w	r3, r1, r3
 8001122:	07dc      	lsls	r4, r3, #31
 8001124:	d5d5      	bpl.n	80010d2 <HAL_RCC_ClockConfig+0x4a>
      {
        return HAL_ERROR;
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001126:	4c39      	ldr	r4, [pc, #228]	; (800120c <HAL_RCC_ClockConfig+0x184>)
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001128:	f241 3888 	movw	r8, #5000	; 0x1388
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
      {
        return HAL_ERROR;
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800112c:	68a3      	ldr	r3, [r4, #8]
 800112e:	f023 0303 	bic.w	r3, r3, #3
 8001132:	431a      	orrs	r2, r3
 8001134:	60a2      	str	r2, [r4, #8]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 8001136:	f7ff f8e3 	bl	8000300 <HAL_GetTick>
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800113a:	6873      	ldr	r3, [r6, #4]
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 800113c:	4607      	mov	r7, r0
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800113e:	2b02      	cmp	r3, #2
 8001140:	d10c      	bne.n	800115c <HAL_RCC_ClockConfig+0xd4>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8001142:	68a3      	ldr	r3, [r4, #8]
 8001144:	f003 030c 	and.w	r3, r3, #12
 8001148:	2b08      	cmp	r3, #8
 800114a:	d0c7      	beq.n	80010dc <HAL_RCC_ClockConfig+0x54>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800114c:	f7ff f8d8 	bl	8000300 <HAL_GetTick>
 8001150:	1bc0      	subs	r0, r0, r7
 8001152:	4540      	cmp	r0, r8
 8001154:	d9f5      	bls.n	8001142 <HAL_RCC_ClockConfig+0xba>
        {
          return HAL_TIMEOUT;
 8001156:	2003      	movs	r0, #3
 8001158:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800115c:	2b03      	cmp	r3, #3
 800115e:	d10a      	bne.n	8001176 <HAL_RCC_ClockConfig+0xee>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8001160:	68a3      	ldr	r3, [r4, #8]
 8001162:	f003 030c 	and.w	r3, r3, #12
 8001166:	2b0c      	cmp	r3, #12
 8001168:	d0b8      	beq.n	80010dc <HAL_RCC_ClockConfig+0x54>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800116a:	f7ff f8c9 	bl	8000300 <HAL_GetTick>
 800116e:	1bc0      	subs	r0, r0, r7
 8001170:	4540      	cmp	r0, r8
 8001172:	d9f5      	bls.n	8001160 <HAL_RCC_ClockConfig+0xd8>
 8001174:	e7ef      	b.n	8001156 <HAL_RCC_ClockConfig+0xce>
        {
          return HAL_TIMEOUT;
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 8001176:	2b01      	cmp	r3, #1
 8001178:	d10f      	bne.n	800119a <HAL_RCC_ClockConfig+0x112>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800117a:	68a3      	ldr	r3, [r4, #8]
 800117c:	f003 030c 	and.w	r3, r3, #12
 8001180:	2b04      	cmp	r3, #4
 8001182:	d0ab      	beq.n	80010dc <HAL_RCC_ClockConfig+0x54>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001184:	f7ff f8bc 	bl	8000300 <HAL_GetTick>
 8001188:	1bc0      	subs	r0, r0, r7
 800118a:	4540      	cmp	r0, r8
 800118c:	d9f5      	bls.n	800117a <HAL_RCC_ClockConfig+0xf2>
 800118e:	e7e2      	b.n	8001156 <HAL_RCC_ClockConfig+0xce>
    }      
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001190:	f7ff f8b6 	bl	8000300 <HAL_GetTick>
 8001194:	1bc0      	subs	r0, r0, r7
 8001196:	4540      	cmp	r0, r8
 8001198:	d8dd      	bhi.n	8001156 <HAL_RCC_ClockConfig+0xce>
        }
      }
    }      
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
 800119a:	68a3      	ldr	r3, [r4, #8]
 800119c:	f013 0f0c 	tst.w	r3, #12
 80011a0:	d1f6      	bne.n	8001190 <HAL_RCC_ClockConfig+0x108>
 80011a2:	e79b      	b.n	80010dc <HAL_RCC_ClockConfig+0x54>
  }    
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80011a4:	681a      	ldr	r2, [r3, #0]
 80011a6:	f022 0201 	bic.w	r2, r2, #1
 80011aa:	601a      	str	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80011ac:	681b      	ldr	r3, [r3, #0]
 80011ae:	07da      	lsls	r2, r3, #31
 80011b0:	d48f      	bmi.n	80010d2 <HAL_RCC_ClockConfig+0x4a>
      return HAL_ERROR;
    }
  }    

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80011b2:	6831      	ldr	r1, [r6, #0]
 80011b4:	0748      	lsls	r0, r1, #29
 80011b6:	d506      	bpl.n	80011c6 <HAL_RCC_ClockConfig+0x13e>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80011b8:	4814      	ldr	r0, [pc, #80]	; (800120c <HAL_RCC_ClockConfig+0x184>)
 80011ba:	6883      	ldr	r3, [r0, #8]
 80011bc:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 80011c0:	68f3      	ldr	r3, [r6, #12]
 80011c2:	4313      	orrs	r3, r2
 80011c4:	6083      	str	r3, [r0, #8]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80011c6:	070b      	lsls	r3, r1, #28
 80011c8:	d507      	bpl.n	80011da <HAL_RCC_ClockConfig+0x152>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 80011ca:	4a10      	ldr	r2, [pc, #64]	; (800120c <HAL_RCC_ClockConfig+0x184>)
 80011cc:	6931      	ldr	r1, [r6, #16]
 80011ce:	6893      	ldr	r3, [r2, #8]
 80011d0:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 80011d4:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 80011d8:	6093      	str	r3, [r2, #8]
  }
 
  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
 80011da:	f7ff ff0f 	bl	8000ffc <HAL_RCC_GetSysClockFreq>
 80011de:	4b0b      	ldr	r3, [pc, #44]	; (800120c <HAL_RCC_ClockConfig+0x184>)
 80011e0:	22f0      	movs	r2, #240	; 0xf0
 80011e2:	689b      	ldr	r3, [r3, #8]
 80011e4:	fa92 f2a2 	rbit	r2, r2
 80011e8:	fab2 f282 	clz	r2, r2
 80011ec:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80011f0:	40d3      	lsrs	r3, r2
 80011f2:	4a07      	ldr	r2, [pc, #28]	; (8001210 <HAL_RCC_ClockConfig+0x188>)
 80011f4:	5cd3      	ldrb	r3, [r2, r3]
 80011f6:	40d8      	lsrs	r0, r3
 80011f8:	4b06      	ldr	r3, [pc, #24]	; (8001214 <HAL_RCC_ClockConfig+0x18c>)
 80011fa:	6018      	str	r0, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 80011fc:	200f      	movs	r0, #15
 80011fe:	f7ff f84d 	bl	800029c <HAL_InitTick>
  
  return HAL_OK;
 8001202:	2000      	movs	r0, #0
}
 8001204:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001208:	40023c00 	.word	0x40023c00
 800120c:	40023800 	.word	0x40023800
 8001210:	08002204 	.word	0x08002204
 8001214:	20000008 	.word	0x20000008

08001218 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_BITNUMBER]);
 8001218:	4b08      	ldr	r3, [pc, #32]	; (800123c <HAL_RCC_GetPCLK1Freq+0x24>)
 800121a:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 800121e:	689b      	ldr	r3, [r3, #8]
 8001220:	fa92 f2a2 	rbit	r2, r2
 8001224:	fab2 f282 	clz	r2, r2
 8001228:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800122c:	40d3      	lsrs	r3, r2
 800122e:	4a04      	ldr	r2, [pc, #16]	; (8001240 <HAL_RCC_GetPCLK1Freq+0x28>)
 8001230:	5cd3      	ldrb	r3, [r2, r3]
 8001232:	4a04      	ldr	r2, [pc, #16]	; (8001244 <HAL_RCC_GetPCLK1Freq+0x2c>)
 8001234:	6810      	ldr	r0, [r2, #0]
}    
 8001236:	40d8      	lsrs	r0, r3
 8001238:	4770      	bx	lr
 800123a:	bf00      	nop
 800123c:	40023800 	.word	0x40023800
 8001240:	08002214 	.word	0x08002214
 8001244:	20000008 	.word	0x20000008

08001248 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_BITNUMBER]);
 8001248:	4b08      	ldr	r3, [pc, #32]	; (800126c <HAL_RCC_GetPCLK2Freq+0x24>)
 800124a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800124e:	689b      	ldr	r3, [r3, #8]
 8001250:	fa92 f2a2 	rbit	r2, r2
 8001254:	fab2 f282 	clz	r2, r2
 8001258:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
 800125c:	40d3      	lsrs	r3, r2
 800125e:	4a04      	ldr	r2, [pc, #16]	; (8001270 <HAL_RCC_GetPCLK2Freq+0x28>)
 8001260:	5cd3      	ldrb	r3, [r2, r3]
 8001262:	4a04      	ldr	r2, [pc, #16]	; (8001274 <HAL_RCC_GetPCLK2Freq+0x2c>)
 8001264:	6810      	ldr	r0, [r2, #0]
} 
 8001266:	40d8      	lsrs	r0, r3
 8001268:	4770      	bx	lr
 800126a:	bf00      	nop
 800126c:	40023800 	.word	0x40023800
 8001270:	08002214 	.word	0x08002214
 8001274:	20000008 	.word	0x20000008

08001278 <TIM_Base_SetConfig>:
{
  uint32_t tmpcr1 = 0;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8001278:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
  * @retval None
  */
static void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
  uint32_t tmpcr1 = 0;
  tmpcr1 = TIMx->CR1;
 800127c:	6803      	ldr	r3, [r0, #0]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800127e:	d00e      	beq.n	800129e <TIM_Base_SetConfig+0x26>
 8001280:	4a1c      	ldr	r2, [pc, #112]	; (80012f4 <TIM_Base_SetConfig+0x7c>)
 8001282:	4290      	cmp	r0, r2
 8001284:	d00b      	beq.n	800129e <TIM_Base_SetConfig+0x26>
 8001286:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800128a:	4290      	cmp	r0, r2
 800128c:	d007      	beq.n	800129e <TIM_Base_SetConfig+0x26>
 800128e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001292:	4290      	cmp	r0, r2
 8001294:	d003      	beq.n	800129e <TIM_Base_SetConfig+0x26>
 8001296:	f502 427c 	add.w	r2, r2, #64512	; 0xfc00
 800129a:	4290      	cmp	r0, r2
 800129c:	d116      	bne.n	80012cc <TIM_Base_SetConfig+0x54>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
 800129e:	684a      	ldr	r2, [r1, #4]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80012a0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
  }

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80012a4:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
 80012a8:	ea43 0302 	orr.w	r3, r3, r2
  }

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80012ac:	d015      	beq.n	80012da <TIM_Base_SetConfig+0x62>
 80012ae:	4a11      	ldr	r2, [pc, #68]	; (80012f4 <TIM_Base_SetConfig+0x7c>)
 80012b0:	4290      	cmp	r0, r2
 80012b2:	d012      	beq.n	80012da <TIM_Base_SetConfig+0x62>
 80012b4:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80012b8:	4290      	cmp	r0, r2
 80012ba:	d00e      	beq.n	80012da <TIM_Base_SetConfig+0x62>
 80012bc:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80012c0:	4290      	cmp	r0, r2
 80012c2:	d00a      	beq.n	80012da <TIM_Base_SetConfig+0x62>
 80012c4:	f502 427c 	add.w	r2, r2, #64512	; 0xfc00
 80012c8:	4290      	cmp	r0, r2
 80012ca:	d006      	beq.n	80012da <TIM_Base_SetConfig+0x62>
 80012cc:	4a0a      	ldr	r2, [pc, #40]	; (80012f8 <TIM_Base_SetConfig+0x80>)
 80012ce:	4290      	cmp	r0, r2
 80012d0:	d003      	beq.n	80012da <TIM_Base_SetConfig+0x62>
 80012d2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80012d6:	4290      	cmp	r0, r2
 80012d8:	d103      	bne.n	80012e2 <TIM_Base_SetConfig+0x6a>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80012da:	68ca      	ldr	r2, [r1, #12]
  }

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 80012dc:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80012e0:	4313      	orrs	r3, r2
  }

  TIMx->CR1 = tmpcr1;
 80012e2:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 80012e4:	688b      	ldr	r3, [r1, #8]
 80012e6:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 80012e8:	680b      	ldr	r3, [r1, #0]
 80012ea:	6283      	str	r3, [r0, #40]	; 0x28

  /* Generate an update event to reload the Prescaler */
  TIMx->EGR = TIM_EGR_UG;
 80012ec:	2301      	movs	r3, #1
 80012ee:	6143      	str	r3, [r0, #20]
 80012f0:	4770      	bx	lr
 80012f2:	bf00      	nop
 80012f4:	40000400 	.word	0x40000400
 80012f8:	40010c00 	.word	0x40010c00

080012fc <TIM_OC1_SetConfig>:
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

   /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80012fc:	6a03      	ldr	r3, [r0, #32]
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The ouput configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 80012fe:	b530      	push	{r4, r5, lr}
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

   /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8001300:	f023 0301 	bic.w	r3, r3, #1
 8001304:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8001306:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8001308:	6845      	ldr	r5, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800130a:	6982      	ldr	r2, [r0, #24]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 800130c:	f022 0473 	bic.w	r4, r2, #115	; 0x73
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8001310:	680a      	ldr	r2, [r1, #0]
 8001312:	4322      	orrs	r2, r4

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 8001314:	f023 0402 	bic.w	r4, r3, #2
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8001318:	688b      	ldr	r3, [r1, #8]

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800131a:	6045      	str	r5, [r0, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800131c:	6182      	str	r2, [r0, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 800131e:	684a      	ldr	r2, [r1, #4]
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8001320:	4323      	orrs	r3, r4

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8001322:	6342      	str	r2, [r0, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8001324:	6203      	str	r3, [r0, #32]
 8001326:	bd30      	pop	{r4, r5, pc}

08001328 <TIM_OC2_SetConfig>:
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8001328:	6a03      	ldr	r3, [r0, #32]
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The ouput configuration structure
  * @retval None
  */
static void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800132a:	b530      	push	{r4, r5, lr}
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800132c:	f023 0310 	bic.w	r3, r3, #16
 8001330:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8001332:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8001334:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8001336:	6982      	ldr	r2, [r0, #24]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
  tmpccmrx &= ~TIM_CCMR1_CC2S;

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 8001338:	680d      	ldr	r5, [r1, #0]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 800133a:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 800133e:	ea42 2205 	orr.w	r2, r2, r5, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4);
 8001342:	688d      	ldr	r5, [r1, #8]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 8001344:	f023 0320 	bic.w	r3, r3, #32
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4);

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8001348:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800134a:	6182      	str	r2, [r0, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 800134c:	684a      	ldr	r2, [r1, #4]
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4);
 800134e:	ea43 1305 	orr.w	r3, r3, r5, lsl #4

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 8001352:	6382      	str	r2, [r0, #56]	; 0x38

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8001354:	6203      	str	r3, [r0, #32]
 8001356:	bd30      	pop	{r4, r5, pc}

08001358 <TIM_CCxChannelCmd>:
  * @param  ChannelState: specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable.
  * @retval None
  */
static void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
{
 8001358:	b510      	push	{r4, lr}
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << Channel;

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 800135a:	2301      	movs	r3, #1
 800135c:	6a04      	ldr	r4, [r0, #32]
 800135e:	408b      	lsls	r3, r1
 8001360:	ea24 0303 	bic.w	r3, r4, r3
 8001364:	6203      	str	r3, [r0, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
 8001366:	6a03      	ldr	r3, [r0, #32]
 8001368:	408a      	lsls	r2, r1
 800136a:	ea42 0103 	orr.w	r1, r2, r3
 800136e:	6201      	str	r1, [r0, #32]
 8001370:	bd10      	pop	{r4, pc}

08001372 <HAL_TIM_PWM_Init>:
  *         parameters in the TIM_HandleTypeDef and create the associated handle.
  * @param  htim: TIM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
 8001372:	b510      	push	{r4, lr}
  /* Check the TIM handle allocation */
  if(htim == NULL)
 8001374:	4604      	mov	r4, r0
 8001376:	b1a0      	cbz	r0, 80013a2 <HAL_TIM_PWM_Init+0x30>
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));

  if(htim->State == HAL_TIM_STATE_RESET)
 8001378:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 800137c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001380:	b91b      	cbnz	r3, 800138a <HAL_TIM_PWM_Init+0x18>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 8001382:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34

    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
 8001386:	f000 fdbd 	bl	8001f04 <HAL_TIM_PWM_MspInit>
  }

  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;
 800138a:	2302      	movs	r3, #2
 800138c:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

  /* Init the base time for the PWM */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8001390:	6820      	ldr	r0, [r4, #0]
 8001392:	1d21      	adds	r1, r4, #4
 8001394:	f7ff ff70 	bl	8001278 <TIM_Base_SetConfig>

  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 8001398:	2301      	movs	r3, #1
 800139a:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

  return HAL_OK;
 800139e:	2000      	movs	r0, #0
 80013a0:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if(htim == NULL)
  {
    return HAL_ERROR;
 80013a2:	2001      	movs	r0, #1

  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;

  return HAL_OK;
}
 80013a4:	bd10      	pop	{r4, pc}
	...

080013a8 <HAL_TIM_PWM_Start_DMA>:
  * @param  pData: The source Buffer address.
  * @param  Length: The length of data to be transferred from memory to TIM peripheral
  * @retval HAL status
*/
HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
{
 80013a8:	b538      	push	{r3, r4, r5, lr}
 80013aa:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  if((htim->State == HAL_TIM_STATE_BUSY))
 80013ac:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
  * @param  pData: The source Buffer address.
  * @param  Length: The length of data to be transferred from memory to TIM peripheral
  * @retval HAL status
*/
HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
{
 80013b0:	460d      	mov	r5, r1
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  if((htim->State == HAL_TIM_STATE_BUSY))
 80013b2:	b2c0      	uxtb	r0, r0
 80013b4:	2802      	cmp	r0, #2
  * @param  pData: The source Buffer address.
  * @param  Length: The length of data to be transferred from memory to TIM peripheral
  * @retval HAL status
*/
HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
{
 80013b6:	4611      	mov	r1, r2
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  if((htim->State == HAL_TIM_STATE_BUSY))
 80013b8:	d05a      	beq.n	8001470 <HAL_TIM_PWM_Start_DMA+0xc8>
  {
     return HAL_BUSY;
  }
  else if((htim->State == HAL_TIM_STATE_READY))
 80013ba:	f894 0035 	ldrb.w	r0, [r4, #53]	; 0x35
 80013be:	b2c0      	uxtb	r0, r0
 80013c0:	2801      	cmp	r0, #1
 80013c2:	d154      	bne.n	800146e <HAL_TIM_PWM_Start_DMA+0xc6>
  {
    if(((uint32_t)pData == 0 ) && (Length > 0))
 80013c4:	b90a      	cbnz	r2, 80013ca <HAL_TIM_PWM_Start_DMA+0x22>
 80013c6:	2b00      	cmp	r3, #0
 80013c8:	d152      	bne.n	8001470 <HAL_TIM_PWM_Start_DMA+0xc8>
    {
      return HAL_ERROR;
    }
    else
    {
      htim->State = HAL_TIM_STATE_BUSY;
 80013ca:	2202      	movs	r2, #2
 80013cc:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35
  else
  {
    return HAL_ERROR;
  }

  switch (Channel)
 80013d0:	2d0c      	cmp	r5, #12
 80013d2:	d840      	bhi.n	8001456 <HAL_TIM_PWM_Start_DMA+0xae>
 80013d4:	e8df f005 	tbb	[pc, r5]
 80013d8:	3f3f3f07 	.word	0x3f3f3f07
 80013dc:	3f3f3f15 	.word	0x3f3f3f15
 80013e0:	3f3f3f23 	.word	0x3f3f3f23
 80013e4:	31          	.byte	0x31
 80013e5:	00          	.byte	0x00
  {
    case TIM_CHANNEL_1:
    {
      /* Set the DMA Period elapsed callback */
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
 80013e6:	69e0      	ldr	r0, [r4, #28]
 80013e8:	4a22      	ldr	r2, [pc, #136]	; (8001474 <HAL_TIM_PWM_Start_DMA+0xcc>)
 80013ea:	6282      	str	r2, [r0, #40]	; 0x28

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
 80013ec:	4a22      	ldr	r2, [pc, #136]	; (8001478 <HAL_TIM_PWM_Start_DMA+0xd0>)
 80013ee:	6302      	str	r2, [r0, #48]	; 0x30

      /* Enable the DMA channel */
      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
 80013f0:	6822      	ldr	r2, [r4, #0]
 80013f2:	3234      	adds	r2, #52	; 0x34
 80013f4:	f7ff f880 	bl	80004f8 <HAL_DMA_Start_IT>

      /* Enable the TIM Capture/Compare 1 DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
 80013f8:	6822      	ldr	r2, [r4, #0]
 80013fa:	68d3      	ldr	r3, [r2, #12]
 80013fc:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8001400:	e028      	b.n	8001454 <HAL_TIM_PWM_Start_DMA+0xac>
    break;

    case TIM_CHANNEL_2:
    {
      /* Set the DMA Period elapsed callback */
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
 8001402:	6a20      	ldr	r0, [r4, #32]
 8001404:	4a1b      	ldr	r2, [pc, #108]	; (8001474 <HAL_TIM_PWM_Start_DMA+0xcc>)
 8001406:	6282      	str	r2, [r0, #40]	; 0x28

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
 8001408:	4a1b      	ldr	r2, [pc, #108]	; (8001478 <HAL_TIM_PWM_Start_DMA+0xd0>)
 800140a:	6302      	str	r2, [r0, #48]	; 0x30

      /* Enable the DMA channel */
      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
 800140c:	6822      	ldr	r2, [r4, #0]
 800140e:	3238      	adds	r2, #56	; 0x38
 8001410:	f7ff f872 	bl	80004f8 <HAL_DMA_Start_IT>

      /* Enable the TIM Capture/Compare 2 DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
 8001414:	6822      	ldr	r2, [r4, #0]
 8001416:	68d3      	ldr	r3, [r2, #12]
 8001418:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800141c:	e01a      	b.n	8001454 <HAL_TIM_PWM_Start_DMA+0xac>
    break;

    case TIM_CHANNEL_3:
    {
      /* Set the DMA Period elapsed callback */
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
 800141e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8001420:	4a14      	ldr	r2, [pc, #80]	; (8001474 <HAL_TIM_PWM_Start_DMA+0xcc>)
 8001422:	6282      	str	r2, [r0, #40]	; 0x28

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
 8001424:	4a14      	ldr	r2, [pc, #80]	; (8001478 <HAL_TIM_PWM_Start_DMA+0xd0>)
 8001426:	6302      	str	r2, [r0, #48]	; 0x30

      /* Enable the DMA channel */
      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
 8001428:	6822      	ldr	r2, [r4, #0]
 800142a:	323c      	adds	r2, #60	; 0x3c
 800142c:	f7ff f864 	bl	80004f8 <HAL_DMA_Start_IT>

      /* Enable the TIM Output Capture/Compare 3 request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
 8001430:	6822      	ldr	r2, [r4, #0]
 8001432:	68d3      	ldr	r3, [r2, #12]
 8001434:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8001438:	e00c      	b.n	8001454 <HAL_TIM_PWM_Start_DMA+0xac>
    break;

    case TIM_CHANNEL_4:
    {
     /* Set the DMA Period elapsed callback */
      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
 800143a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800143c:	4a0d      	ldr	r2, [pc, #52]	; (8001474 <HAL_TIM_PWM_Start_DMA+0xcc>)
 800143e:	6282      	str	r2, [r0, #40]	; 0x28

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
 8001440:	4a0d      	ldr	r2, [pc, #52]	; (8001478 <HAL_TIM_PWM_Start_DMA+0xd0>)
 8001442:	6302      	str	r2, [r0, #48]	; 0x30

      /* Enable the DMA channel */
      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
 8001444:	6822      	ldr	r2, [r4, #0]
 8001446:	3240      	adds	r2, #64	; 0x40
 8001448:	f7ff f856 	bl	80004f8 <HAL_DMA_Start_IT>

      /* Enable the TIM Capture/Compare 4 DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
 800144c:	6822      	ldr	r2, [r4, #0]
 800144e:	68d3      	ldr	r3, [r2, #12]
 8001450:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001454:	60d3      	str	r3, [r2, #12]
    default:
    break;
  }

  /* Enable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8001456:	6820      	ldr	r0, [r4, #0]
 8001458:	2201      	movs	r2, #1
 800145a:	4629      	mov	r1, r5
 800145c:	f7ff ff7c 	bl	8001358 <TIM_CCxChannelCmd>

  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 8001460:	6822      	ldr	r2, [r4, #0]

  /* Return function status */
  return HAL_OK;
 8001462:	2000      	movs	r0, #0

  /* Enable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);

  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 8001464:	6813      	ldr	r3, [r2, #0]
 8001466:	f043 0301 	orr.w	r3, r3, #1
 800146a:	6013      	str	r3, [r2, #0]

  /* Return function status */
  return HAL_OK;
 800146c:	bd38      	pop	{r3, r4, r5, pc}
      htim->State = HAL_TIM_STATE_BUSY;
    }
  }
  else
  {
    return HAL_ERROR;
 800146e:	2001      	movs	r0, #1
  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);

  /* Return function status */
  return HAL_OK;
}
 8001470:	bd38      	pop	{r3, r4, r5, pc}
 8001472:	bf00      	nop
 8001474:	0800158f 	.word	0x0800158f
 8001478:	080015cb 	.word	0x080015cb

0800147c <HAL_TIM_PWM_ConfigChannel>:
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
{
  __HAL_LOCK(htim);
 800147c:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
{
 8001480:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(htim);
 8001482:	2b01      	cmp	r3, #1
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
{
 8001484:	4605      	mov	r5, r0
 8001486:	460c      	mov	r4, r1
 8001488:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(htim);
 800148c:	d07d      	beq.n	800158a <HAL_TIM_PWM_ConfigChannel+0x10e>
 800148e:	2301      	movs	r3, #1
 8001490:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
  assert_param(IS_TIM_CHANNELS(Channel));
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  htim->State = HAL_TIM_STATE_BUSY;
 8001494:	f885 0035 	strb.w	r0, [r5, #53]	; 0x35

  switch (Channel)
 8001498:	2a0c      	cmp	r2, #12
 800149a:	d870      	bhi.n	800157e <HAL_TIM_PWM_ConfigChannel+0x102>
 800149c:	e8df f002 	tbb	[pc, r2]
 80014a0:	6f6f6f07 	.word	0x6f6f6f07
 80014a4:	6f6f6f17 	.word	0x6f6f6f17
 80014a8:	6f6f6f29 	.word	0x6f6f6f29
 80014ac:	4b          	.byte	0x4b
 80014ad:	00          	.byte	0x00
  {
    case TIM_CHANNEL_1:
    {
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
      /* Configure the Channel 1 in PWM mode */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 80014ae:	6828      	ldr	r0, [r5, #0]
 80014b0:	f7ff ff24 	bl	80012fc <TIM_OC1_SetConfig>

      /* Set the Preload enable bit for channel1 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 80014b4:	682b      	ldr	r3, [r5, #0]
 80014b6:	699a      	ldr	r2, [r3, #24]
 80014b8:	f042 0208 	orr.w	r2, r2, #8
 80014bc:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 80014be:	699a      	ldr	r2, [r3, #24]
 80014c0:	f022 0204 	bic.w	r2, r2, #4
 80014c4:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 80014c6:	6999      	ldr	r1, [r3, #24]
 80014c8:	68e2      	ldr	r2, [r4, #12]
 80014ca:	430a      	orrs	r2, r1
 80014cc:	e00f      	b.n	80014ee <HAL_TIM_PWM_ConfigChannel+0x72>

    case TIM_CHANNEL_2:
    {
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 80014ce:	6828      	ldr	r0, [r5, #0]
 80014d0:	f7ff ff2a 	bl	8001328 <TIM_OC2_SetConfig>

      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 80014d4:	682b      	ldr	r3, [r5, #0]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
 80014d6:	68c9      	ldr	r1, [r1, #12]
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);

      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 80014d8:	699a      	ldr	r2, [r3, #24]
 80014da:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80014de:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 80014e0:	699a      	ldr	r2, [r3, #24]
 80014e2:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80014e6:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
 80014e8:	699a      	ldr	r2, [r3, #24]
 80014ea:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80014ee:	619a      	str	r2, [r3, #24]
    }
    break;
 80014f0:	e045      	b.n	800157e <HAL_TIM_PWM_ConfigChannel+0x102>

    case TIM_CHANNEL_3:
    {
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
      /* Configure the Channel 3 in PWM mode */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 80014f2:	682b      	ldr	r3, [r5, #0]
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 80014f4:	6a1a      	ldr	r2, [r3, #32]
 80014f6:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80014fa:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80014fc:	6a1a      	ldr	r2, [r3, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80014fe:	685e      	ldr	r6, [r3, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8001500:	69d9      	ldr	r1, [r3, #28]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 8001502:	f422 7200 	bic.w	r2, r2, #512	; 0x200
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8001506:	f021 0073 	bic.w	r0, r1, #115	; 0x73
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800150a:	6821      	ldr	r1, [r4, #0]
 800150c:	4301      	orrs	r1, r0

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8);
 800150e:	68a0      	ldr	r0, [r4, #8]

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8001510:	605e      	str	r6, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8001512:	61d9      	str	r1, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8001514:	6861      	ldr	r1, [r4, #4]
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8);
 8001516:	ea42 2200 	orr.w	r2, r2, r0, lsl #8

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 800151a:	63d9      	str	r1, [r3, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800151c:	621a      	str	r2, [r3, #32]
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
      /* Configure the Channel 3 in PWM mode */
      TIM_OC3_SetConfig(htim->Instance, sConfig);

      /* Set the Preload enable bit for channel3 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 800151e:	69da      	ldr	r2, [r3, #28]
 8001520:	f042 0208 	orr.w	r2, r2, #8
 8001524:	61da      	str	r2, [r3, #28]

     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8001526:	69da      	ldr	r2, [r3, #28]
 8001528:	f022 0204 	bic.w	r2, r2, #4
 800152c:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 800152e:	69d9      	ldr	r1, [r3, #28]
 8001530:	68e2      	ldr	r2, [r4, #12]
 8001532:	430a      	orrs	r2, r1
 8001534:	e022      	b.n	800157c <HAL_TIM_PWM_ConfigChannel+0x100>

    case TIM_CHANNEL_4:
    {
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8001536:	682b      	ldr	r3, [r5, #0]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 8001538:	6826      	ldr	r6, [r4, #0]
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 800153a:	6a1a      	ldr	r2, [r3, #32]
 800153c:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8001540:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8001542:	6a1a      	ldr	r2, [r3, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8001544:	6858      	ldr	r0, [r3, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8001546:	69d9      	ldr	r1, [r3, #28]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 8001548:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 800154c:	f421 41e6 	bic.w	r1, r1, #29440	; 0x7300

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 8001550:	ea41 2106 	orr.w	r1, r1, r6, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12);
 8001554:	68a6      	ldr	r6, [r4, #8]

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8001556:	6058      	str	r0, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8001558:	61d9      	str	r1, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 800155a:	6861      	ldr	r1, [r4, #4]
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12);
 800155c:	ea42 3206 	orr.w	r2, r2, r6, lsl #12

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8001560:	6419      	str	r1, [r3, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8001562:	621a      	str	r2, [r3, #32]
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);

      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8001564:	69da      	ldr	r2, [r3, #28]

     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;
 8001566:	68e1      	ldr	r1, [r4, #12]
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);

      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8001568:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800156c:	61da      	str	r2, [r3, #28]

     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 800156e:	69da      	ldr	r2, [r3, #28]
 8001570:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8001574:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;
 8001576:	69da      	ldr	r2, [r3, #28]
 8001578:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800157c:	61da      	str	r2, [r3, #28]

    default:
    break;
  }

  htim->State = HAL_TIM_STATE_READY;
 800157e:	2301      	movs	r3, #1

  __HAL_UNLOCK(htim);
 8001580:	2000      	movs	r0, #0

    default:
    break;
  }

  htim->State = HAL_TIM_STATE_READY;
 8001582:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35

  __HAL_UNLOCK(htim);
 8001586:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34

  return HAL_OK;
}
 800158a:	bd70      	pop	{r4, r5, r6, pc}

0800158c <HAL_TIM_PWM_PulseFinishedCallback>:
 800158c:	4770      	bx	lr

0800158e <TIM_DMADelayPulseCplt>:
  * @brief  TIM DMA Delay Pulse complete callback.
  * @param  hdma : pointer to DMA handle.
  * @retval None
  */
void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
{
 800158e:	b510      	push	{r4, lr}
  TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8001590:	6a44      	ldr	r4, [r0, #36]	; 0x24

  htim->State= HAL_TIM_STATE_READY;
 8001592:	2301      	movs	r3, #1

  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
 8001594:	69e2      	ldr	r2, [r4, #28]
  */
void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
{
  TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;

  htim->State= HAL_TIM_STATE_READY;
 8001596:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
 800159a:	4290      	cmp	r0, r2
 800159c:	d00d      	beq.n	80015ba <TIM_DMADelayPulseCplt+0x2c>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
 800159e:	6a23      	ldr	r3, [r4, #32]
 80015a0:	4298      	cmp	r0, r3
 80015a2:	d101      	bne.n	80015a8 <TIM_DMADelayPulseCplt+0x1a>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 80015a4:	2302      	movs	r3, #2
 80015a6:	e008      	b.n	80015ba <TIM_DMADelayPulseCplt+0x2c>
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
 80015a8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80015aa:	4298      	cmp	r0, r3
 80015ac:	d101      	bne.n	80015b2 <TIM_DMADelayPulseCplt+0x24>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 80015ae:	2304      	movs	r3, #4
 80015b0:	e003      	b.n	80015ba <TIM_DMADelayPulseCplt+0x2c>
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
 80015b2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80015b4:	4298      	cmp	r0, r3
 80015b6:	d101      	bne.n	80015bc <TIM_DMADelayPulseCplt+0x2e>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 80015b8:	2308      	movs	r3, #8
 80015ba:	7523      	strb	r3, [r4, #20]
  }

  HAL_TIM_PWM_PulseFinishedCallback(htim);
 80015bc:	4620      	mov	r0, r4
 80015be:	f7ff ffe5 	bl	800158c <HAL_TIM_PWM_PulseFinishedCallback>

  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80015c2:	2300      	movs	r3, #0
 80015c4:	7523      	strb	r3, [r4, #20]
 80015c6:	bd10      	pop	{r4, pc}

080015c8 <HAL_TIM_ErrorCallback>:
  * @brief  Timer error callback in non blocking mode
  * @param  htim : TIM handle
  * @retval None
  */
__weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
{
 80015c8:	4770      	bx	lr

080015ca <TIM_DMAError>:
  * @brief  TIM DMA error callback
  * @param  hdma : pointer to DMA handle.
  * @retval None
  */
void TIM_DMAError(DMA_HandleTypeDef *hdma)
{
 80015ca:	b508      	push	{r3, lr}
  TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 80015cc:	6a40      	ldr	r0, [r0, #36]	; 0x24

  htim->State= HAL_TIM_STATE_READY;
 80015ce:	2301      	movs	r3, #1
 80015d0:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35

  HAL_TIM_ErrorCallback(htim);
 80015d4:	f7ff fff8 	bl	80015c8 <HAL_TIM_ErrorCallback>
 80015d8:	bd08      	pop	{r3, pc}
	...

080015dc <UART_SetConfig>:
  * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 80015dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80015e0:	4681      	mov	r9, r0
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*------- UART-associated USART registers setting : CR2 Configuration ------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
   * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80015e2:	6806      	ldr	r6, [r0, #0]
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
  MODIFY_REG(huart->Instance->CR1, 
 80015e4:	f8d9 1008 	ldr.w	r1, [r9, #8]
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*------- UART-associated USART registers setting : CR2 Configuration ------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
   * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80015e8:	6933      	ldr	r3, [r6, #16]
 80015ea:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
 80015ee:	68c3      	ldr	r3, [r0, #12]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80015f0:	69c0      	ldr	r0, [r0, #28]
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*------- UART-associated USART registers setting : CR2 Configuration ------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
   * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80015f2:	4313      	orrs	r3, r2
 80015f4:	6133      	str	r3, [r6, #16]
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
  MODIFY_REG(huart->Instance->CR1, 
 80015f6:	f8d9 3010 	ldr.w	r3, [r9, #16]
 80015fa:	68f2      	ldr	r2, [r6, #12]
 80015fc:	4319      	orrs	r1, r3
 80015fe:	f8d9 3014 	ldr.w	r3, [r9, #20]
  /*------- UART-associated USART registers setting : CR3 Configuration ------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8001602:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
  MODIFY_REG(huart->Instance->CR1, 
 8001606:	ea43 0301 	orr.w	r3, r3, r1
 800160a:	ea43 0100 	orr.w	r1, r3, r0
 800160e:	f422 4316 	bic.w	r3, r2, #38400	; 0x9600
 8001612:	f023 030c 	bic.w	r3, r3, #12
 8001616:	ea43 0301 	orr.w	r3, r3, r1
 800161a:	60f3      	str	r3, [r6, #12]
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8), 
             tmpreg);
  
  /*------- UART-associated USART registers setting : CR3 Configuration ------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 800161c:	6973      	ldr	r3, [r6, #20]
 800161e:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8001622:	f8d9 3018 	ldr.w	r3, [r9, #24]
 8001626:	ea43 0302 	orr.w	r3, r3, r2
 800162a:	6173      	str	r3, [r6, #20]
 800162c:	4b7d      	ldr	r3, [pc, #500]	; (8001824 <UART_SetConfig+0x248>)
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800162e:	d17d      	bne.n	800172c <UART_SetConfig+0x150>
  {
    /*------- UART-associated USART registers setting : BRR Configuration ------*/
    if((huart->Instance == USART1))
 8001630:	429e      	cmp	r6, r3
 8001632:	f04f 0419 	mov.w	r4, #25
 8001636:	d132      	bne.n	800169e <UART_SetConfig+0xc2>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8001638:	f7ff fe06 	bl	8001248 <HAL_RCC_GetPCLK2Freq>
 800163c:	4360      	muls	r0, r4
 800163e:	f8d9 7004 	ldr.w	r7, [r9, #4]
 8001642:	f04f 0864 	mov.w	r8, #100	; 0x64
 8001646:	007f      	lsls	r7, r7, #1
 8001648:	fbb0 f7f7 	udiv	r7, r0, r7
 800164c:	f7ff fdfc 	bl	8001248 <HAL_RCC_GetPCLK2Freq>
 8001650:	4360      	muls	r0, r4
 8001652:	f8d9 5004 	ldr.w	r5, [r9, #4]
 8001656:	fbb7 f7f8 	udiv	r7, r7, r8
 800165a:	006d      	lsls	r5, r5, #1
 800165c:	fbb0 f5f5 	udiv	r5, r0, r5
 8001660:	f7ff fdf2 	bl	8001248 <HAL_RCC_GetPCLK2Freq>
 8001664:	4360      	muls	r0, r4
 8001666:	f8d9 3004 	ldr.w	r3, [r9, #4]
 800166a:	013f      	lsls	r7, r7, #4
 800166c:	005b      	lsls	r3, r3, #1
 800166e:	fbb0 f0f3 	udiv	r0, r0, r3
 8001672:	fbb0 f0f8 	udiv	r0, r0, r8
 8001676:	fb08 5510 	mls	r5, r8, r0, r5
 800167a:	f7ff fde5 	bl	8001248 <HAL_RCC_GetPCLK2Freq>
 800167e:	00ed      	lsls	r5, r5, #3
 8001680:	3532      	adds	r5, #50	; 0x32
 8001682:	fbb5 f5f8 	udiv	r5, r5, r8
 8001686:	4360      	muls	r0, r4
 8001688:	f8d9 1004 	ldr.w	r1, [r9, #4]
 800168c:	006d      	lsls	r5, r5, #1
 800168e:	0049      	lsls	r1, r1, #1
 8001690:	f405 75f8 	and.w	r5, r5, #496	; 0x1f0
 8001694:	fbb0 faf1 	udiv	sl, r0, r1
 8001698:	f7ff fdd6 	bl	8001248 <HAL_RCC_GetPCLK2Freq>
 800169c:	e031      	b.n	8001702 <UART_SetConfig+0x126>
    }
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 800169e:	f7ff fdbb 	bl	8001218 <HAL_RCC_GetPCLK1Freq>
 80016a2:	4360      	muls	r0, r4
 80016a4:	f8d9 7004 	ldr.w	r7, [r9, #4]
 80016a8:	f04f 0864 	mov.w	r8, #100	; 0x64
 80016ac:	007f      	lsls	r7, r7, #1
 80016ae:	fbb0 f7f7 	udiv	r7, r0, r7
 80016b2:	f7ff fdb1 	bl	8001218 <HAL_RCC_GetPCLK1Freq>
 80016b6:	4360      	muls	r0, r4
 80016b8:	f8d9 5004 	ldr.w	r5, [r9, #4]
 80016bc:	fbb7 f7f8 	udiv	r7, r7, r8
 80016c0:	006d      	lsls	r5, r5, #1
 80016c2:	fbb0 f5f5 	udiv	r5, r0, r5
 80016c6:	f7ff fda7 	bl	8001218 <HAL_RCC_GetPCLK1Freq>
 80016ca:	4360      	muls	r0, r4
 80016cc:	f8d9 3004 	ldr.w	r3, [r9, #4]
 80016d0:	013f      	lsls	r7, r7, #4
 80016d2:	005b      	lsls	r3, r3, #1
 80016d4:	fbb0 f0f3 	udiv	r0, r0, r3
 80016d8:	fbb0 f0f8 	udiv	r0, r0, r8
 80016dc:	fb08 5510 	mls	r5, r8, r0, r5
 80016e0:	f7ff fd9a 	bl	8001218 <HAL_RCC_GetPCLK1Freq>
 80016e4:	00ed      	lsls	r5, r5, #3
 80016e6:	3532      	adds	r5, #50	; 0x32
 80016e8:	fbb5 f5f8 	udiv	r5, r5, r8
 80016ec:	4360      	muls	r0, r4
 80016ee:	f8d9 1004 	ldr.w	r1, [r9, #4]
 80016f2:	006d      	lsls	r5, r5, #1
 80016f4:	0049      	lsls	r1, r1, #1
 80016f6:	f405 75f8 	and.w	r5, r5, #496	; 0x1f0
 80016fa:	fbb0 faf1 	udiv	sl, r0, r1
 80016fe:	f7ff fd8b 	bl	8001218 <HAL_RCC_GetPCLK1Freq>
 8001702:	4344      	muls	r4, r0
 8001704:	f8d9 0004 	ldr.w	r0, [r9, #4]
 8001708:	0040      	lsls	r0, r0, #1
 800170a:	fbb4 f0f0 	udiv	r0, r4, r0
 800170e:	fbb0 f0f8 	udiv	r0, r0, r8
 8001712:	fb08 a210 	mls	r2, r8, r0, sl
 8001716:	00d2      	lsls	r2, r2, #3
 8001718:	3232      	adds	r2, #50	; 0x32
 800171a:	fbb2 f3f8 	udiv	r3, r2, r8
 800171e:	f003 0307 	and.w	r3, r3, #7
 8001722:	443b      	add	r3, r7
 8001724:	441d      	add	r5, r3
 8001726:	60b5      	str	r5, [r6, #8]
 8001728:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    }
  }
  else
  {
    /*------- UART-associated USART registers setting : BRR Configuration ------*/
    if((huart->Instance == USART1))
 800172c:	429e      	cmp	r6, r3
 800172e:	f04f 0419 	mov.w	r4, #25
 8001732:	d131      	bne.n	8001798 <UART_SetConfig+0x1bc>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8001734:	f7ff fd88 	bl	8001248 <HAL_RCC_GetPCLK2Freq>
 8001738:	4360      	muls	r0, r4
 800173a:	f8d9 7004 	ldr.w	r7, [r9, #4]
 800173e:	f04f 0864 	mov.w	r8, #100	; 0x64
 8001742:	00bf      	lsls	r7, r7, #2
 8001744:	fbb0 f7f7 	udiv	r7, r0, r7
 8001748:	f7ff fd7e 	bl	8001248 <HAL_RCC_GetPCLK2Freq>
 800174c:	4360      	muls	r0, r4
 800174e:	f8d9 5004 	ldr.w	r5, [r9, #4]
 8001752:	fbb7 f7f8 	udiv	r7, r7, r8
 8001756:	00ad      	lsls	r5, r5, #2
 8001758:	fbb0 f5f5 	udiv	r5, r0, r5
 800175c:	f7ff fd74 	bl	8001248 <HAL_RCC_GetPCLK2Freq>
 8001760:	4360      	muls	r0, r4
 8001762:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8001766:	013f      	lsls	r7, r7, #4
 8001768:	009b      	lsls	r3, r3, #2
 800176a:	fbb0 f0f3 	udiv	r0, r0, r3
 800176e:	fbb0 f0f8 	udiv	r0, r0, r8
 8001772:	fb08 5510 	mls	r5, r8, r0, r5
 8001776:	f7ff fd67 	bl	8001248 <HAL_RCC_GetPCLK2Freq>
 800177a:	012d      	lsls	r5, r5, #4
 800177c:	3532      	adds	r5, #50	; 0x32
 800177e:	fbb5 f5f8 	udiv	r5, r5, r8
 8001782:	4360      	muls	r0, r4
 8001784:	f8d9 1004 	ldr.w	r1, [r9, #4]
 8001788:	f005 05f0 	and.w	r5, r5, #240	; 0xf0
 800178c:	0089      	lsls	r1, r1, #2
 800178e:	fbb0 faf1 	udiv	sl, r0, r1
 8001792:	f7ff fd59 	bl	8001248 <HAL_RCC_GetPCLK2Freq>
 8001796:	e030      	b.n	80017fa <UART_SetConfig+0x21e>
    }
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8001798:	f7ff fd3e 	bl	8001218 <HAL_RCC_GetPCLK1Freq>
 800179c:	4360      	muls	r0, r4
 800179e:	f8d9 7004 	ldr.w	r7, [r9, #4]
 80017a2:	f04f 0864 	mov.w	r8, #100	; 0x64
 80017a6:	00bf      	lsls	r7, r7, #2
 80017a8:	fbb0 f7f7 	udiv	r7, r0, r7
 80017ac:	f7ff fd34 	bl	8001218 <HAL_RCC_GetPCLK1Freq>
 80017b0:	4360      	muls	r0, r4
 80017b2:	f8d9 5004 	ldr.w	r5, [r9, #4]
 80017b6:	fbb7 f7f8 	udiv	r7, r7, r8
 80017ba:	00ad      	lsls	r5, r5, #2
 80017bc:	fbb0 f5f5 	udiv	r5, r0, r5
 80017c0:	f7ff fd2a 	bl	8001218 <HAL_RCC_GetPCLK1Freq>
 80017c4:	4360      	muls	r0, r4
 80017c6:	f8d9 3004 	ldr.w	r3, [r9, #4]
 80017ca:	013f      	lsls	r7, r7, #4
 80017cc:	009b      	lsls	r3, r3, #2
 80017ce:	fbb0 f0f3 	udiv	r0, r0, r3
 80017d2:	fbb0 f0f8 	udiv	r0, r0, r8
 80017d6:	fb08 5510 	mls	r5, r8, r0, r5
 80017da:	f7ff fd1d 	bl	8001218 <HAL_RCC_GetPCLK1Freq>
 80017de:	012d      	lsls	r5, r5, #4
 80017e0:	3532      	adds	r5, #50	; 0x32
 80017e2:	fbb5 f5f8 	udiv	r5, r5, r8
 80017e6:	4360      	muls	r0, r4
 80017e8:	f8d9 1004 	ldr.w	r1, [r9, #4]
 80017ec:	f005 05f0 	and.w	r5, r5, #240	; 0xf0
 80017f0:	0089      	lsls	r1, r1, #2
 80017f2:	fbb0 faf1 	udiv	sl, r0, r1
 80017f6:	f7ff fd0f 	bl	8001218 <HAL_RCC_GetPCLK1Freq>
 80017fa:	4344      	muls	r4, r0
 80017fc:	f8d9 0004 	ldr.w	r0, [r9, #4]
 8001800:	0080      	lsls	r0, r0, #2
 8001802:	fbb4 f0f0 	udiv	r0, r4, r0
 8001806:	fbb0 f0f8 	udiv	r0, r0, r8
 800180a:	fb08 a210 	mls	r2, r8, r0, sl
 800180e:	0112      	lsls	r2, r2, #4
 8001810:	3232      	adds	r2, #50	; 0x32
 8001812:	fbb2 f3f8 	udiv	r3, r2, r8
 8001816:	f003 030f 	and.w	r3, r3, #15
 800181a:	442b      	add	r3, r5
 800181c:	441f      	add	r7, r3
 800181e:	60b7      	str	r7, [r6, #8]
 8001820:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001824:	40013800 	.word	0x40013800

08001828 <HAL_UART_Init>:
  * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 8001828:	b510      	push	{r4, lr}
  /* Check the UART handle allocation */
  if(huart == NULL)
 800182a:	4604      	mov	r4, r0
 800182c:	b330      	cbz	r0, 800187c <HAL_UART_Init+0x54>
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
  
  if(huart->State == HAL_UART_STATE_RESET)
 800182e:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8001832:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001836:	b91b      	cbnz	r3, 8001840 <HAL_UART_Init+0x18>
  {  
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8001838:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38

    /* Init the low level hardware */
    HAL_UART_MspInit(huart);
 800183c:	f000 fbba 	bl	8001fb4 <HAL_UART_MspInit>
  }

  huart->State = HAL_UART_STATE_BUSY;

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8001840:	6822      	ldr	r2, [r4, #0]

    /* Init the low level hardware */
    HAL_UART_MspInit(huart);
  }

  huart->State = HAL_UART_STATE_BUSY;
 8001842:	2302      	movs	r3, #2
 8001844:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8001848:	68d3      	ldr	r3, [r2, #12]
  
  /* Set the UART Communication parameters */
  UART_SetConfig(huart);
 800184a:	4620      	mov	r0, r4
  }

  huart->State = HAL_UART_STATE_BUSY;

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 800184c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8001850:	60d3      	str	r3, [r2, #12]
  
  /* Set the UART Communication parameters */
  UART_SetConfig(huart);
 8001852:	f7ff fec3 	bl	80015dc <UART_SetConfig>
  
  /* In asynchronous mode, the following bits must be kept cleared: 
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8001856:	6823      	ldr	r3, [r4, #0]
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
  
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001858:	2000      	movs	r0, #0
  UART_SetConfig(huart);
  
  /* In asynchronous mode, the following bits must be kept cleared: 
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800185a:	691a      	ldr	r2, [r3, #16]
 800185c:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8001860:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8001862:	695a      	ldr	r2, [r3, #20]
 8001864:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8001868:	615a      	str	r2, [r3, #20]
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 800186a:	68da      	ldr	r2, [r3, #12]
 800186c:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8001870:	60da      	str	r2, [r3, #12]
  
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
  huart->State= HAL_UART_STATE_READY;
 8001872:	2301      	movs	r3, #1
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
  
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001874:	63e0      	str	r0, [r4, #60]	; 0x3c
  huart->State= HAL_UART_STATE_READY;
 8001876:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  
  return HAL_OK;
 800187a:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
  /* Check the UART handle allocation */
  if(huart == NULL)
  {
    return HAL_ERROR;
 800187c:	2001      	movs	r0, #1
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
  huart->State= HAL_UART_STATE_READY;
  
  return HAL_OK;
}
 800187e:	bd10      	pop	{r4, pc}

08001880 <HAL_UART_DeInit>:
  * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
{
 8001880:	b538      	push	{r3, r4, r5, lr}
  /* Check the UART handle allocation */
  if(huart == NULL)
 8001882:	4605      	mov	r5, r0
 8001884:	b1a0      	cbz	r0, 80018b0 <HAL_UART_DeInit+0x30>
  }
  
  /* Check the parameters */
  assert_param(IS_UART_INSTANCE(huart->Instance));

  huart->State = HAL_UART_STATE_BUSY;
 8001886:	2302      	movs	r3, #2
 8001888:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
  
  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 800188c:	6803      	ldr	r3, [r0, #0]
  
  huart->Instance->CR1 = 0x0;
 800188e:	2400      	movs	r4, #0
  assert_param(IS_UART_INSTANCE(huart->Instance));

  huart->State = HAL_UART_STATE_BUSY;
  
  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 8001890:	68da      	ldr	r2, [r3, #12]
 8001892:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8001896:	60da      	str	r2, [r3, #12]
  
  huart->Instance->CR1 = 0x0;
 8001898:	60dc      	str	r4, [r3, #12]
  huart->Instance->CR2 = 0x0;
 800189a:	611c      	str	r4, [r3, #16]
  huart->Instance->CR3 = 0x0;
 800189c:	615c      	str	r4, [r3, #20]
  
  /* DeInit the low level hardware */
  HAL_UART_MspDeInit(huart);
 800189e:	f000 fc15 	bl	80020cc <HAL_UART_MspDeInit>

  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80018a2:	63ec      	str	r4, [r5, #60]	; 0x3c
  huart->State = HAL_UART_STATE_RESET;

  /* Process Unlock */
  __HAL_UNLOCK(huart);
 80018a4:	f885 4038 	strb.w	r4, [r5, #56]	; 0x38
  
  /* DeInit the low level hardware */
  HAL_UART_MspDeInit(huart);

  huart->ErrorCode = HAL_UART_ERROR_NONE;
  huart->State = HAL_UART_STATE_RESET;
 80018a8:	f885 4039 	strb.w	r4, [r5, #57]	; 0x39

  /* Process Unlock */
  __HAL_UNLOCK(huart);

  return HAL_OK;
 80018ac:	4620      	mov	r0, r4
 80018ae:	bd38      	pop	{r3, r4, r5, pc}
HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
{
  /* Check the UART handle allocation */
  if(huart == NULL)
  {
    return HAL_ERROR;
 80018b0:	2001      	movs	r0, #1

  /* Process Unlock */
  __HAL_UNLOCK(huart);

  return HAL_OK;
}
 80018b2:	bd38      	pop	{r3, r4, r5, pc}

080018b4 <HAL_UART_Transmit_DMA>:
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 80018b4:	4613      	mov	r3, r2
  uint32_t *tmp;
  uint32_t tmp_state = 0;

  tmp_state = huart->State;
 80018b6:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 80018ba:	b510      	push	{r4, lr}
  uint32_t *tmp;
  uint32_t tmp_state = 0;

  tmp_state = huart->State;
 80018bc:	b2d2      	uxtb	r2, r2
  if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
 80018be:	2a01      	cmp	r2, #1
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 80018c0:	4604      	mov	r4, r0
  uint32_t *tmp;
  uint32_t tmp_state = 0;

  tmp_state = huart->State;
  if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
 80018c2:	d001      	beq.n	80018c8 <HAL_UART_Transmit_DMA+0x14>
 80018c4:	2a22      	cmp	r2, #34	; 0x22
 80018c6:	d12e      	bne.n	8001926 <HAL_UART_Transmit_DMA+0x72>
  {
    if((pData == NULL ) || (Size == 0)) 
 80018c8:	b359      	cbz	r1, 8001922 <HAL_UART_Transmit_DMA+0x6e>
 80018ca:	b353      	cbz	r3, 8001922 <HAL_UART_Transmit_DMA+0x6e>
    {
      return HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 80018cc:	f894 2038 	ldrb.w	r2, [r4, #56]	; 0x38
 80018d0:	2a01      	cmp	r2, #1
 80018d2:	d028      	beq.n	8001926 <HAL_UART_Transmit_DMA+0x72>
 80018d4:	2201      	movs	r2, #1
 80018d6:	f884 2038 	strb.w	r2, [r4, #56]	; 0x38

    huart->pTxBuffPtr = pData;
    huart->TxXferSize = Size;
    huart->TxXferCount = Size;

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80018da:	2200      	movs	r2, #0
 80018dc:	63e2      	str	r2, [r4, #60]	; 0x3c
    /* Check if a receive process is ongoing or not */
    if(huart->State == HAL_UART_STATE_BUSY_RX)
 80018de:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
    {
      huart->State = HAL_UART_STATE_BUSY_TX;
    }

    /* Set the UART DMA transfer complete callback */
    huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 80018e2:	6b20      	ldr	r0, [r4, #48]	; 0x30
    huart->TxXferSize = Size;
    huart->TxXferCount = Size;

    huart->ErrorCode = HAL_UART_ERROR_NONE;
    /* Check if a receive process is ongoing or not */
    if(huart->State == HAL_UART_STATE_BUSY_RX)
 80018e4:	2a22      	cmp	r2, #34	; 0x22
    {
      huart->State = HAL_UART_STATE_BUSY_TX_RX;
 80018e6:	bf0c      	ite	eq
 80018e8:	2232      	moveq	r2, #50	; 0x32
    }
    else
    {
      huart->State = HAL_UART_STATE_BUSY_TX;
 80018ea:	2212      	movne	r2, #18
 80018ec:	f884 2039 	strb.w	r2, [r4, #57]	; 0x39
    }

    /* Set the UART DMA transfer complete callback */
    huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 80018f0:	4a0e      	ldr	r2, [pc, #56]	; (800192c <HAL_UART_Transmit_DMA+0x78>)

    /* Process Locked */
    __HAL_LOCK(huart);

    huart->pTxBuffPtr = pData;
    huart->TxXferSize = Size;
 80018f2:	84a3      	strh	r3, [r4, #36]	; 0x24
    huart->TxXferCount = Size;
 80018f4:	84e3      	strh	r3, [r4, #38]	; 0x26
    }

    /* Process Locked */
    __HAL_LOCK(huart);

    huart->pTxBuffPtr = pData;
 80018f6:	6221      	str	r1, [r4, #32]
    {
      huart->State = HAL_UART_STATE_BUSY_TX;
    }

    /* Set the UART DMA transfer complete callback */
    huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 80018f8:	6282      	str	r2, [r0, #40]	; 0x28

    /* Set the UART DMA Half transfer complete callback */
    huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 80018fa:	4a0d      	ldr	r2, [pc, #52]	; (8001930 <HAL_UART_Transmit_DMA+0x7c>)
 80018fc:	62c2      	str	r2, [r0, #44]	; 0x2c

    /* Set the DMA error callback */
    huart->hdmatx->XferErrorCallback = UART_DMAError;
 80018fe:	4a0d      	ldr	r2, [pc, #52]	; (8001934 <HAL_UART_Transmit_DMA+0x80>)
 8001900:	6302      	str	r2, [r0, #48]	; 0x30

    /* Enable the UART transmit DMA channel */
    tmp = (uint32_t*)&pData;
    HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
 8001902:	6822      	ldr	r2, [r4, #0]
 8001904:	3204      	adds	r2, #4
 8001906:	f7fe fdf7 	bl	80004f8 <HAL_DMA_Start_IT>

    /* Clear the TC flag in the SR register by writing 0 to it */
    __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
 800190a:	6823      	ldr	r3, [r4, #0]
 800190c:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8001910:	601a      	str	r2, [r3, #0]

    /* Enable the DMA transfer for transmit request by setting the DMAT bit
       in the UART CR3 register */
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8001912:	695a      	ldr	r2, [r3, #20]

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 8001914:	2000      	movs	r0, #0
    /* Clear the TC flag in the SR register by writing 0 to it */
    __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);

    /* Enable the DMA transfer for transmit request by setting the DMAT bit
       in the UART CR3 register */
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8001916:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800191a:	615a      	str	r2, [r3, #20]

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 800191c:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38

    return HAL_OK;
 8001920:	bd10      	pop	{r4, pc}
  tmp_state = huart->State;
  if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
  {
    if((pData == NULL ) || (Size == 0)) 
    {
      return HAL_ERROR;
 8001922:	2001      	movs	r0, #1
 8001924:	bd10      	pop	{r4, pc}

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8001926:	2002      	movs	r0, #2
  }
}
 8001928:	bd10      	pop	{r4, pc}
 800192a:	bf00      	nop
 800192c:	080019b7 	.word	0x080019b7
 8001930:	080019e5 	.word	0x080019e5
 8001934:	08001a2d 	.word	0x08001a2d

08001938 <HAL_UART_Receive_DMA>:
  * @note   When the UART parity is enabled (PCE = 1), the received data contain 
  *         the parity bit (MSB position)     
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8001938:	b538      	push	{r3, r4, r5, lr}
 800193a:	4604      	mov	r4, r0
  uint32_t *tmp;
  uint32_t tmp_state = 0;

  tmp_state = huart->State;
 800193c:	f890 0039 	ldrb.w	r0, [r0, #57]	; 0x39
  * @note   When the UART parity is enabled (PCE = 1), the received data contain 
  *         the parity bit (MSB position)     
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8001940:	4613      	mov	r3, r2
  uint32_t *tmp;
  uint32_t tmp_state = 0;

  tmp_state = huart->State;
 8001942:	b2c0      	uxtb	r0, r0
  if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
 8001944:	2801      	cmp	r0, #1
 8001946:	d001      	beq.n	800194c <HAL_UART_Receive_DMA+0x14>
 8001948:	2812      	cmp	r0, #18
 800194a:	d12b      	bne.n	80019a4 <HAL_UART_Receive_DMA+0x6c>
  {
    if((pData == NULL ) || (Size == 0))
 800194c:	b341      	cbz	r1, 80019a0 <HAL_UART_Receive_DMA+0x68>
 800194e:	b33b      	cbz	r3, 80019a0 <HAL_UART_Receive_DMA+0x68>
    {
      return HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 8001950:	f894 2038 	ldrb.w	r2, [r4, #56]	; 0x38
 8001954:	2a01      	cmp	r2, #1
 8001956:	d025      	beq.n	80019a4 <HAL_UART_Receive_DMA+0x6c>
 8001958:	2201      	movs	r2, #1
 800195a:	f884 2038 	strb.w	r2, [r4, #56]	; 0x38

    huart->pRxBuffPtr = pData;
    huart->RxXferSize = Size;

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800195e:	2200      	movs	r2, #0
 8001960:	63e2      	str	r2, [r4, #60]	; 0x3c
    /* Check if a transmit process is ongoing or not */
    if(huart->State == HAL_UART_STATE_BUSY_TX)
 8001962:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
    {
      huart->State = HAL_UART_STATE_BUSY_RX;
    }

    /* Set the UART DMA transfer complete callback */
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 8001966:	6b60      	ldr	r0, [r4, #52]	; 0x34
    huart->pRxBuffPtr = pData;
    huart->RxXferSize = Size;

    huart->ErrorCode = HAL_UART_ERROR_NONE;
    /* Check if a transmit process is ongoing or not */
    if(huart->State == HAL_UART_STATE_BUSY_TX)
 8001968:	2a12      	cmp	r2, #18
    {
      huart->State = HAL_UART_STATE_BUSY_TX_RX;
 800196a:	bf0c      	ite	eq
 800196c:	2232      	moveq	r2, #50	; 0x32
    }
    else
    {
      huart->State = HAL_UART_STATE_BUSY_RX;
 800196e:	2222      	movne	r2, #34	; 0x22
 8001970:	f884 2039 	strb.w	r2, [r4, #57]	; 0x39
    }

    /* Set the UART DMA transfer complete callback */
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 8001974:	4a0c      	ldr	r2, [pc, #48]	; (80019a8 <HAL_UART_Receive_DMA+0x70>)
    }

    /* Process Locked */
    __HAL_LOCK(huart);

    huart->pRxBuffPtr = pData;
 8001976:	62a1      	str	r1, [r4, #40]	; 0x28
    huart->RxXferSize = Size;
 8001978:	85a3      	strh	r3, [r4, #44]	; 0x2c
    {
      huart->State = HAL_UART_STATE_BUSY_RX;
    }

    /* Set the UART DMA transfer complete callback */
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 800197a:	6282      	str	r2, [r0, #40]	; 0x28

    /* Set the UART DMA Half transfer complete callback */
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 800197c:	4a0b      	ldr	r2, [pc, #44]	; (80019ac <HAL_UART_Receive_DMA+0x74>)
    /* Set the DMA error callback */
    huart->hdmarx->XferErrorCallback = UART_DMAError;

    /* Enable the DMA channel */
    tmp = (uint32_t*)&pData;
    HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
 800197e:	6825      	ldr	r5, [r4, #0]

    /* Set the UART DMA transfer complete callback */
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;

    /* Set the UART DMA Half transfer complete callback */
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 8001980:	62c2      	str	r2, [r0, #44]	; 0x2c

    /* Set the DMA error callback */
    huart->hdmarx->XferErrorCallback = UART_DMAError;
 8001982:	4a0b      	ldr	r2, [pc, #44]	; (80019b0 <HAL_UART_Receive_DMA+0x78>)
 8001984:	6302      	str	r2, [r0, #48]	; 0x30

    /* Enable the DMA channel */
    tmp = (uint32_t*)&pData;
    HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
 8001986:	460a      	mov	r2, r1
 8001988:	1d29      	adds	r1, r5, #4
 800198a:	f7fe fdb5 	bl	80004f8 <HAL_DMA_Start_IT>

    /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
       in the UART CR3 register */
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800198e:	6822      	ldr	r2, [r4, #0]

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 8001990:	2000      	movs	r0, #0
    tmp = (uint32_t*)&pData;
    HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);

    /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
       in the UART CR3 register */
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8001992:	6953      	ldr	r3, [r2, #20]
 8001994:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001998:	6153      	str	r3, [r2, #20]

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 800199a:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38

    return HAL_OK;
 800199e:	bd38      	pop	{r3, r4, r5, pc}
  tmp_state = huart->State;
  if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
  {
    if((pData == NULL ) || (Size == 0))
    {
      return HAL_ERROR;
 80019a0:	2001      	movs	r0, #1
 80019a2:	bd38      	pop	{r3, r4, r5, pc}

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 80019a4:	2002      	movs	r0, #2
  }
}
 80019a6:	bd38      	pop	{r3, r4, r5, pc}
 80019a8:	080019ef 	.word	0x080019ef
 80019ac:	08001a23 	.word	0x08001a23
 80019b0:	08001a2d 	.word	0x08001a2d

080019b4 <HAL_UART_TxCpltCallback>:
 80019b4:	4770      	bx	lr

080019b6 <UART_DMATransmitCplt>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)     
{
 80019b6:	b508      	push	{r3, lr}
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  /* DMA Normal mode*/
  if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
 80019b8:	6803      	ldr	r3, [r0, #0]
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)     
{
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 80019ba:	6a42      	ldr	r2, [r0, #36]	; 0x24
  /* DMA Normal mode*/
  if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
 80019bc:	681b      	ldr	r3, [r3, #0]
 80019be:	f013 0320 	ands.w	r3, r3, #32
 80019c2:	d10a      	bne.n	80019da <UART_DMATransmitCplt+0x24>
  {
    huart->TxXferCount = 0;
 80019c4:	84d3      	strh	r3, [r2, #38]	; 0x26

    /* Disable the DMA transfer for transmit request by setting the DMAT bit
       in the UART CR3 register */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 80019c6:	6813      	ldr	r3, [r2, #0]
 80019c8:	695a      	ldr	r2, [r3, #20]
 80019ca:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80019ce:	615a      	str	r2, [r3, #20]

    /* Enable the UART Transmit Complete Interrupt */    
    __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
 80019d0:	68da      	ldr	r2, [r3, #12]
 80019d2:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80019d6:	60da      	str	r2, [r3, #12]
 80019d8:	bd08      	pop	{r3, pc}
  }
  /* DMA Circular mode */
  else
  {
    HAL_UART_TxCpltCallback(huart);
 80019da:	4610      	mov	r0, r2
 80019dc:	f7ff ffea 	bl	80019b4 <HAL_UART_TxCpltCallback>
 80019e0:	bd08      	pop	{r3, pc}

080019e2 <HAL_UART_TxHalfCpltCallback>:
 80019e2:	4770      	bx	lr

080019e4 <UART_DMATxHalfCplt>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 80019e4:	b508      	push	{r3, lr}
  UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;

  HAL_UART_TxHalfCpltCallback(huart);
 80019e6:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80019e8:	f7ff fffb 	bl	80019e2 <HAL_UART_TxHalfCpltCallback>
 80019ec:	bd08      	pop	{r3, pc}

080019ee <UART_DMAReceiveCplt>:
  */
static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)  
{
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  /* DMA Normal mode*/
  if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
 80019ee:	6802      	ldr	r2, [r0, #0]
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)  
{
 80019f0:	b508      	push	{r3, lr}
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  /* DMA Normal mode*/
  if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
 80019f2:	6812      	ldr	r2, [r2, #0]
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)  
{
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 80019f4:	6a43      	ldr	r3, [r0, #36]	; 0x24
  /* DMA Normal mode*/
  if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
 80019f6:	f012 0220 	ands.w	r2, r2, #32
 80019fa:	d10d      	bne.n	8001a18 <UART_DMAReceiveCplt+0x2a>
  {
    huart->RxXferCount = 0;
  
    /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
       in the UART CR3 register */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 80019fc:	6819      	ldr	r1, [r3, #0]
{
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  /* DMA Normal mode*/
  if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
  {
    huart->RxXferCount = 0;
 80019fe:	85da      	strh	r2, [r3, #46]	; 0x2e
  
    /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
       in the UART CR3 register */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8001a00:	694a      	ldr	r2, [r1, #20]
 8001a02:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001a06:	614a      	str	r2, [r1, #20]

    /* Check if a transmit process is ongoing or not */
    if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
 8001a08:	f893 2039 	ldrb.w	r2, [r3, #57]	; 0x39
 8001a0c:	2a32      	cmp	r2, #50	; 0x32
    {
      huart->State = HAL_UART_STATE_BUSY_TX;
 8001a0e:	bf0c      	ite	eq
 8001a10:	2212      	moveq	r2, #18
    }
    else
    {
      huart->State = HAL_UART_STATE_READY;
 8001a12:	2201      	movne	r2, #1
 8001a14:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    }
  }
  HAL_UART_RxCpltCallback(huart);
 8001a18:	4618      	mov	r0, r3
 8001a1a:	f000 fa2d 	bl	8001e78 <HAL_UART_RxCpltCallback>
 8001a1e:	bd08      	pop	{r3, pc}

08001a20 <HAL_UART_RxHalfCpltCallback>:
 8001a20:	4770      	bx	lr

08001a22 <UART_DMARxHalfCplt>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
 8001a22:	b508      	push	{r3, lr}
  UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;

  HAL_UART_RxHalfCpltCallback(huart); 
 8001a24:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8001a26:	f7ff fffb 	bl	8001a20 <HAL_UART_RxHalfCpltCallback>
 8001a2a:	bd08      	pop	{r3, pc}

08001a2c <UART_DMAError>:
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)   
{
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8001a2c:	6a40      	ldr	r0, [r0, #36]	; 0x24
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)   
{
 8001a2e:	b508      	push	{r3, lr}
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  huart->RxXferCount = 0;
 8001a30:	2300      	movs	r3, #0
 8001a32:	85c3      	strh	r3, [r0, #46]	; 0x2e
  huart->TxXferCount = 0;
 8001a34:	84c3      	strh	r3, [r0, #38]	; 0x26
  huart->State= HAL_UART_STATE_READY;
 8001a36:	2301      	movs	r3, #1
 8001a38:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 8001a3c:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8001a3e:	f043 0310 	orr.w	r3, r3, #16
 8001a42:	63c3      	str	r3, [r0, #60]	; 0x3c
  HAL_UART_ErrorCallback(huart);
 8001a44:	f000 fa50 	bl	8001ee8 <HAL_UART_ErrorCallback>
 8001a48:	bd08      	pop	{r3, pc}

08001a4a <HAL_UART_IRQHandler>:
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
  uint32_t tmp_flag = 0, tmp_it_source = 0;

  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_PE);
 8001a4a:	6802      	ldr	r2, [r0, #0]
  * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 8001a4c:	b513      	push	{r0, r1, r4, lr}
  uint32_t tmp_flag = 0, tmp_it_source = 0;

  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_PE);
 8001a4e:	6811      	ldr	r1, [r2, #0]
  * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 8001a50:	4604      	mov	r4, r0
  uint32_t tmp_flag = 0, tmp_it_source = 0;

  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_PE);
  tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_PE);  
  /* UART parity error interrupt occurred ------------------------------------*/
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
 8001a52:	07c9      	lsls	r1, r1, #31
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
  uint32_t tmp_flag = 0, tmp_it_source = 0;

  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_PE);
  tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_PE);  
 8001a54:	68d3      	ldr	r3, [r2, #12]
  /* UART parity error interrupt occurred ------------------------------------*/
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
 8001a56:	d505      	bpl.n	8001a64 <HAL_UART_IRQHandler+0x1a>
 8001a58:	05db      	lsls	r3, r3, #23
  { 
    huart->ErrorCode |= HAL_UART_ERROR_PE;
 8001a5a:	bf42      	ittt	mi
 8001a5c:	6bc3      	ldrmi	r3, [r0, #60]	; 0x3c
 8001a5e:	f043 0301 	orrmi.w	r3, r3, #1
 8001a62:	63c3      	strmi	r3, [r0, #60]	; 0x3c
  }
  
  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_FE);
 8001a64:	6811      	ldr	r1, [r2, #0]
  tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR);
 8001a66:	6953      	ldr	r3, [r2, #20]
  /* UART frame error interrupt occurred -------------------------------------*/
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
 8001a68:	0788      	lsls	r0, r1, #30
  { 
    huart->ErrorCode |= HAL_UART_ERROR_PE;
  }
  
  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_FE);
  tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR);
 8001a6a:	f003 0301 	and.w	r3, r3, #1
  /* UART frame error interrupt occurred -------------------------------------*/
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
 8001a6e:	d504      	bpl.n	8001a7a <HAL_UART_IRQHandler+0x30>
 8001a70:	b11b      	cbz	r3, 8001a7a <HAL_UART_IRQHandler+0x30>
  {
    huart->ErrorCode |= HAL_UART_ERROR_FE;
 8001a72:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8001a74:	f041 0104 	orr.w	r1, r1, #4
 8001a78:	63e1      	str	r1, [r4, #60]	; 0x3c
  }
  
  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_NE);
 8001a7a:	6811      	ldr	r1, [r2, #0]
  /* UART noise error interrupt occurred -------------------------------------*/
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
 8001a7c:	0749      	lsls	r1, r1, #29
 8001a7e:	d504      	bpl.n	8001a8a <HAL_UART_IRQHandler+0x40>
 8001a80:	b11b      	cbz	r3, 8001a8a <HAL_UART_IRQHandler+0x40>
  {
    huart->ErrorCode |= HAL_UART_ERROR_NE;
 8001a82:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8001a84:	f041 0102 	orr.w	r1, r1, #2
 8001a88:	63e1      	str	r1, [r4, #60]	; 0x3c
  }
  
  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_ORE);
 8001a8a:	6811      	ldr	r1, [r2, #0]
  /* UART Over-Run interrupt occurred ----------------------------------------*/
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
 8001a8c:	0708      	lsls	r0, r1, #28
 8001a8e:	d504      	bpl.n	8001a9a <HAL_UART_IRQHandler+0x50>
 8001a90:	b11b      	cbz	r3, 8001a9a <HAL_UART_IRQHandler+0x50>
  {
    huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8001a92:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001a94:	f043 0308 	orr.w	r3, r3, #8
 8001a98:	63e3      	str	r3, [r4, #60]	; 0x3c
  }
  
  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE);
 8001a9a:	6811      	ldr	r1, [r2, #0]
  tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_RXNE);
 8001a9c:	68d3      	ldr	r3, [r2, #12]
  /* UART in mode Receiver ---------------------------------------------------*/
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
 8001a9e:	0689      	lsls	r1, r1, #26
 8001aa0:	d542      	bpl.n	8001b28 <HAL_UART_IRQHandler+0xde>
 8001aa2:	0698      	lsls	r0, r3, #26
 8001aa4:	d540      	bpl.n	8001b28 <HAL_UART_IRQHandler+0xde>
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;
  uint32_t tmp_state = 0;
  
  tmp_state = huart->State; 
 8001aa6:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
  if((tmp_state == HAL_UART_STATE_BUSY_RX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
 8001aaa:	f003 03ef 	and.w	r3, r3, #239	; 0xef
 8001aae:	2b22      	cmp	r3, #34	; 0x22
 8001ab0:	d13a      	bne.n	8001b28 <HAL_UART_IRQHandler+0xde>
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8001ab2:	68a3      	ldr	r3, [r4, #8]
 8001ab4:	6921      	ldr	r1, [r4, #16]
 8001ab6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8001aba:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001abc:	d10b      	bne.n	8001ad6 <HAL_UART_IRQHandler+0x8c>
    {
      tmp = (uint16_t*) huart->pRxBuffPtr;
      if(huart->Init.Parity == UART_PARITY_NONE)
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8001abe:	6852      	ldr	r2, [r2, #4]
  if((tmp_state == HAL_UART_STATE_BUSY_RX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
    {
      tmp = (uint16_t*) huart->pRxBuffPtr;
      if(huart->Init.Parity == UART_PARITY_NONE)
 8001ac0:	b921      	cbnz	r1, 8001acc <HAL_UART_IRQHandler+0x82>
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8001ac2:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8001ac6:	f823 2b02 	strh.w	r2, [r3], #2
 8001aca:	e002      	b.n	8001ad2 <HAL_UART_IRQHandler+0x88>
        huart->pRxBuffPtr += 2;
      }
      else
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
 8001acc:	b2d2      	uxtb	r2, r2
 8001ace:	f823 2b01 	strh.w	r2, [r3], #1
        huart->pRxBuffPtr += 1;
 8001ad2:	62a3      	str	r3, [r4, #40]	; 0x28
 8001ad4:	e00a      	b.n	8001aec <HAL_UART_IRQHandler+0xa2>
      }
    }
    else
    {
      if(huart->Init.Parity == UART_PARITY_NONE)
 8001ad6:	b919      	cbnz	r1, 8001ae0 <HAL_UART_IRQHandler+0x96>
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 8001ad8:	1c59      	adds	r1, r3, #1
 8001ada:	62a1      	str	r1, [r4, #40]	; 0x28
 8001adc:	6852      	ldr	r2, [r2, #4]
 8001ade:	e004      	b.n	8001aea <HAL_UART_IRQHandler+0xa0>
      }
      else
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 8001ae0:	6852      	ldr	r2, [r2, #4]
 8001ae2:	1c59      	adds	r1, r3, #1
 8001ae4:	62a1      	str	r1, [r4, #40]	; 0x28
 8001ae6:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8001aea:	701a      	strb	r2, [r3, #0]
      }
    }

    if(--huart->RxXferCount == 0)
 8001aec:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
 8001aee:	3b01      	subs	r3, #1
 8001af0:	b29b      	uxth	r3, r3
 8001af2:	85e3      	strh	r3, [r4, #46]	; 0x2e
 8001af4:	b9c3      	cbnz	r3, 8001b28 <HAL_UART_IRQHandler+0xde>
    {
      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 8001af6:	6823      	ldr	r3, [r4, #0]
        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
        __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);

        huart->State = HAL_UART_STATE_READY;
      }
      HAL_UART_RxCpltCallback(huart);
 8001af8:	4620      	mov	r0, r4
      }
    }

    if(--huart->RxXferCount == 0)
    {
      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 8001afa:	68da      	ldr	r2, [r3, #12]
 8001afc:	f022 0220 	bic.w	r2, r2, #32
 8001b00:	60da      	str	r2, [r3, #12]

      /* Check if a transmit process is ongoing or not */
      if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
 8001b02:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
 8001b06:	2a32      	cmp	r2, #50	; 0x32
        huart->State = HAL_UART_STATE_BUSY_TX;
      }
      else
      {
        /* Disable the UART Parity Error Interrupt */
        __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 8001b08:	bf17      	itett	ne
 8001b0a:	68da      	ldrne	r2, [r3, #12]
      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);

      /* Check if a transmit process is ongoing or not */
      if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
      {
        huart->State = HAL_UART_STATE_BUSY_TX;
 8001b0c:	2312      	moveq	r3, #18
      }
      else
      {
        /* Disable the UART Parity Error Interrupt */
        __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 8001b0e:	f422 7280 	bicne.w	r2, r2, #256	; 0x100
 8001b12:	60da      	strne	r2, [r3, #12]

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
        __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 8001b14:	bf1f      	itttt	ne
 8001b16:	695a      	ldrne	r2, [r3, #20]
 8001b18:	f022 0201 	bicne.w	r2, r2, #1
 8001b1c:	615a      	strne	r2, [r3, #20]

        huart->State = HAL_UART_STATE_READY;
 8001b1e:	2301      	movne	r3, #1
 8001b20:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
      }
      HAL_UART_RxCpltCallback(huart);
 8001b24:	f000 f9a8 	bl	8001e78 <HAL_UART_RxCpltCallback>
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
  { 
    UART_Receive_IT(huart);
  }
  
  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_TXE);
 8001b28:	6823      	ldr	r3, [r4, #0]
 8001b2a:	6819      	ldr	r1, [r3, #0]
  tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TXE);
 8001b2c:	68da      	ldr	r2, [r3, #12]
  /* UART in mode Transmitter ------------------------------------------------*/
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
 8001b2e:	0609      	lsls	r1, r1, #24
 8001b30:	d528      	bpl.n	8001b84 <HAL_UART_IRQHandler+0x13a>
 8001b32:	0610      	lsls	r0, r2, #24
 8001b34:	d526      	bpl.n	8001b84 <HAL_UART_IRQHandler+0x13a>
static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;
  uint32_t tmp_state = 0;
  
  tmp_state = huart->State;
 8001b36:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
  if((tmp_state == HAL_UART_STATE_BUSY_TX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
 8001b3a:	f002 02df 	and.w	r2, r2, #223	; 0xdf
 8001b3e:	2a12      	cmp	r2, #18
 8001b40:	d120      	bne.n	8001b84 <HAL_UART_IRQHandler+0x13a>
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8001b42:	68a2      	ldr	r2, [r4, #8]
 8001b44:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 8001b48:	6a22      	ldr	r2, [r4, #32]
 8001b4a:	d10a      	bne.n	8001b62 <HAL_UART_IRQHandler+0x118>
    {
      tmp = (uint16_t*) huart->pTxBuffPtr;
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
 8001b4c:	8811      	ldrh	r1, [r2, #0]
 8001b4e:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8001b52:	6059      	str	r1, [r3, #4]
      if(huart->Init.Parity == UART_PARITY_NONE)
 8001b54:	6921      	ldr	r1, [r4, #16]
 8001b56:	b909      	cbnz	r1, 8001b5c <HAL_UART_IRQHandler+0x112>
      {
        huart->pTxBuffPtr += 2;
 8001b58:	3202      	adds	r2, #2
 8001b5a:	e000      	b.n	8001b5e <HAL_UART_IRQHandler+0x114>
      }
      else
      {
        huart->pTxBuffPtr += 1;
 8001b5c:	3201      	adds	r2, #1
 8001b5e:	6222      	str	r2, [r4, #32]
 8001b60:	e003      	b.n	8001b6a <HAL_UART_IRQHandler+0x120>
      }
    } 
    else
    {
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
 8001b62:	1c51      	adds	r1, r2, #1
 8001b64:	6221      	str	r1, [r4, #32]
 8001b66:	7812      	ldrb	r2, [r2, #0]
 8001b68:	605a      	str	r2, [r3, #4]
    }

    if(--huart->TxXferCount == 0)
 8001b6a:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 8001b6c:	3a01      	subs	r2, #1
 8001b6e:	b292      	uxth	r2, r2
 8001b70:	84e2      	strh	r2, [r4, #38]	; 0x26
 8001b72:	b93a      	cbnz	r2, 8001b84 <HAL_UART_IRQHandler+0x13a>
    {
      /* Disable the UART Transmit Complete Interrupt */
      __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 8001b74:	68da      	ldr	r2, [r3, #12]
 8001b76:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8001b7a:	60da      	str	r2, [r3, #12]

      /* Enable the UART Transmit Complete Interrupt */    
      __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
 8001b7c:	68da      	ldr	r2, [r3, #12]
 8001b7e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001b82:	60da      	str	r2, [r3, #12]
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
  {
    UART_Transmit_IT(huart);
  }

  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_TC);
 8001b84:	6819      	ldr	r1, [r3, #0]
  tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TC);
 8001b86:	68da      	ldr	r2, [r3, #12]
  /* UART in mode Transmitter end --------------------------------------------*/
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
 8001b88:	0649      	lsls	r1, r1, #25
 8001b8a:	d510      	bpl.n	8001bae <HAL_UART_IRQHandler+0x164>
 8001b8c:	0652      	lsls	r2, r2, #25
 8001b8e:	d50e      	bpl.n	8001bae <HAL_UART_IRQHandler+0x164>
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */    
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 8001b90:	68da      	ldr	r2, [r3, #12]
  else
  {
    huart->State = HAL_UART_STATE_READY;
  }
  
  HAL_UART_TxCpltCallback(huart);
 8001b92:	4620      	mov	r0, r4
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */    
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 8001b94:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001b98:	60da      	str	r2, [r3, #12]
  
  /* Check if a receive process is ongoing or not */
  if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
 8001b9a:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 8001b9e:	2b32      	cmp	r3, #50	; 0x32
  {
    huart->State = HAL_UART_STATE_BUSY_RX;
 8001ba0:	bf0c      	ite	eq
 8001ba2:	2322      	moveq	r3, #34	; 0x22
  }
  else
  {
    huart->State = HAL_UART_STATE_READY;
 8001ba4:	2301      	movne	r3, #1
 8001ba6:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  }
  
  HAL_UART_TxCpltCallback(huart);
 8001baa:	f7ff ff03 	bl	80019b4 <HAL_UART_TxCpltCallback>
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
  {
    UART_EndTransmit_IT(huart);
  }  

  if(huart->ErrorCode != HAL_UART_ERROR_NONE)
 8001bae:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001bb0:	b15b      	cbz	r3, 8001bca <HAL_UART_IRQHandler+0x180>
  {
    /* Clear all the error flag at once */
    __HAL_UART_CLEAR_PEFLAG(huart);
 8001bb2:	6823      	ldr	r3, [r4, #0]
    
    /* Set the UART state ready to be able to start again the process */
    huart->State = HAL_UART_STATE_READY;
    
    HAL_UART_ErrorCallback(huart);
 8001bb4:	4620      	mov	r0, r4
  }  

  if(huart->ErrorCode != HAL_UART_ERROR_NONE)
  {
    /* Clear all the error flag at once */
    __HAL_UART_CLEAR_PEFLAG(huart);
 8001bb6:	681a      	ldr	r2, [r3, #0]
 8001bb8:	9201      	str	r2, [sp, #4]
 8001bba:	685b      	ldr	r3, [r3, #4]
 8001bbc:	9301      	str	r3, [sp, #4]
 8001bbe:	9b01      	ldr	r3, [sp, #4]
    
    /* Set the UART state ready to be able to start again the process */
    huart->State = HAL_UART_STATE_READY;
 8001bc0:	2301      	movs	r3, #1
 8001bc2:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
    
    HAL_UART_ErrorCallback(huart);
 8001bc6:	f000 f98f 	bl	8001ee8 <HAL_UART_ErrorCallback>
  }  
}
 8001bca:	b002      	add	sp, #8
 8001bcc:	bd10      	pop	{r4, pc}
	...

08001bd0 <Reset_Handler>:
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 8001bd0:	2100      	movs	r1, #0
  b LoopCopyDataInit
 8001bd2:	e003      	b.n	8001bdc <LoopCopyDataInit>

08001bd4 <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 8001bd4:	4b0b      	ldr	r3, [pc, #44]	; (8001c04 <LoopFillZerobss+0x14>)
  ldr r3, [r3, r1]
 8001bd6:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 8001bd8:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 8001bda:	3104      	adds	r1, #4

08001bdc <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 8001bdc:	480a      	ldr	r0, [pc, #40]	; (8001c08 <LoopFillZerobss+0x18>)
  ldr r3, =_edata
 8001bde:	4b0b      	ldr	r3, [pc, #44]	; (8001c0c <LoopFillZerobss+0x1c>)
  adds r2, r0, r1
 8001be0:	1842      	adds	r2, r0, r1
  cmp r2, r3
 8001be2:	429a      	cmp	r2, r3
  bcc CopyDataInit
 8001be4:	d3f6      	bcc.n	8001bd4 <CopyDataInit>
  ldr r2, =_sbss
 8001be6:	4a0a      	ldr	r2, [pc, #40]	; (8001c10 <LoopFillZerobss+0x20>)
  b LoopFillZerobss
 8001be8:	e002      	b.n	8001bf0 <LoopFillZerobss>

08001bea <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 8001bea:	2300      	movs	r3, #0
  str r3, [r2], #4
 8001bec:	f842 3b04 	str.w	r3, [r2], #4

08001bf0 <LoopFillZerobss>:

LoopFillZerobss:
  ldr r3, = _ebss
 8001bf0:	4b08      	ldr	r3, [pc, #32]	; (8001c14 <LoopFillZerobss+0x24>)
  cmp r2, r3
 8001bf2:	429a      	cmp	r2, r3
  bcc FillZerobss
 8001bf4:	d3f9      	bcc.n	8001bea <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 8001bf6:	f7fe fb2b 	bl	8000250 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8001bfa:	f000 fab5 	bl	8002168 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8001bfe:	f000 f85b 	bl	8001cb8 <main>
  bx lr
 8001c02:	4770      	bx	lr
/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
  b LoopCopyDataInit

CopyDataInit:
  ldr r3, =_sidata
 8001c04:	08002230 	.word	0x08002230
  ldr r3, [r3, r1]
  str r3, [r0, r1]
  adds r1, r1, #4

LoopCopyDataInit:
  ldr r0, =_sdata
 8001c08:	20000000 	.word	0x20000000
  ldr r3, =_edata
 8001c0c:	200000ac 	.word	0x200000ac
  adds r2, r0, r1
  cmp r2, r3
  bcc CopyDataInit
  ldr r2, =_sbss
 8001c10:	200000ac 	.word	0x200000ac
FillZerobss:
  movs r3, #0
  str r3, [r2], #4

LoopFillZerobss:
  ldr r3, = _ebss
 8001c14:	20001770 	.word	0x20001770

08001c18 <ADC1_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8001c18:	e7fe      	b.n	8001c18 <ADC1_IRQHandler>

08001c1a <Error_Handler>:
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
static void Error_Handler(void)
{
 8001c1a:	b508      	push	{r3, lr}
  /* Turn LED2 on */
  BSP_LED_On(LED2);
 8001c1c:	2000      	movs	r0, #0
 8001c1e:	f7fe fad5 	bl	80001cc <BSP_LED_On>
 8001c22:	e7fe      	b.n	8001c22 <Error_Handler+0x8>

08001c24 <Delay>:

	}

}

void Delay(__IO uint32_t nCount) {
 8001c24:	b082      	sub	sp, #8
 8001c26:	9001      	str	r0, [sp, #4]
  while(nCount--) {
 8001c28:	9b01      	ldr	r3, [sp, #4]
 8001c2a:	1e5a      	subs	r2, r3, #1
 8001c2c:	9201      	str	r2, [sp, #4]
 8001c2e:	2b00      	cmp	r3, #0
 8001c30:	d1fa      	bne.n	8001c28 <Delay+0x4>
  }
}
 8001c32:	b002      	add	sp, #8
 8001c34:	4770      	bx	lr
	...

08001c38 <color2pwm>:

void color2pwm(int pos, uint8_t color1, uint8_t color2, uint8_t color3) {
 8001c38:	b5f0      	push	{r4, r5, r6, r7, lr}

	for (j = 0; j < 8; j++)
	{
		if ( (color1<<j) & 0x80 )
		{
			WS2812_IO_framedata[pwm_pos+j] =(uint32_t)(((uint32_t) 66 * (uwTimerPeriod - 1)) / 100);
 8001c3a:	4c15      	ldr	r4, [pc, #84]	; (8001c90 <color2pwm+0x58>)
 8001c3c:	2642      	movs	r6, #66	; 0x42
 8001c3e:	6825      	ldr	r5, [r4, #0]
 8001c40:	2464      	movs	r4, #100	; 0x64
 8001c42:	436e      	muls	r6, r5
; 	// compare value for logical 1
		}
		else
		{
			WS2812_IO_framedata[pwm_pos+j] = (uint32_t)(((uint32_t) 33 * (uwTimerPeriod - 1)) / 100);// compare value for logical 0
 8001c44:	eb05 1545 	add.w	r5, r5, r5, lsl #5
 8001c48:	3d21      	subs	r5, #33	; 0x21

	for (j = 0; j < 8; j++)
	{
		if ( (color1<<j) & 0x80 )
		{
			WS2812_IO_framedata[pwm_pos+j] =(uint32_t)(((uint32_t) 66 * (uwTimerPeriod - 1)) / 100);
 8001c4a:	3e42      	subs	r6, #66	; 0x42
 8001c4c:	fbb6 f6f4 	udiv	r6, r6, r4
; 	// compare value for logical 1
		}
		else
		{
			WS2812_IO_framedata[pwm_pos+j] = (uint32_t)(((uint32_t) 33 * (uwTimerPeriod - 1)) / 100);// compare value for logical 0
 8001c50:	fbb5 f4f4 	udiv	r4, r5, r4
 8001c54:	2518      	movs	r5, #24
 8001c56:	4368      	muls	r0, r5
 8001c58:	4d0e      	ldr	r5, [pc, #56]	; (8001c94 <color2pwm+0x5c>)
 8001c5a:	eb05 0080 	add.w	r0, r5, r0, lsl #2
		color2 = 255;
	if(color3 > 255)
		color3 = 255;


	for (j = 0; j < 8; j++)
 8001c5e:	2500      	movs	r5, #0
	{
		if ( (color1<<j) & 0x80 )
 8001c60:	fa01 f705 	lsl.w	r7, r1, r5
 8001c64:	063f      	lsls	r7, r7, #24
		else
		{
			WS2812_IO_framedata[pwm_pos+j] = (uint32_t)(((uint32_t) 33 * (uwTimerPeriod - 1)) / 100);// compare value for logical 0
		}

		if ( (color2<<j) & 0x80 )	// data sent MSB first, j = 0 is MSB j = 7 is LSB
 8001c66:	fa02 f705 	lsl.w	r7, r2, r5

	for (j = 0; j < 8; j++)
	{
		if ( (color1<<j) & 0x80 )
		{
			WS2812_IO_framedata[pwm_pos+j] =(uint32_t)(((uint32_t) 66 * (uwTimerPeriod - 1)) / 100);
 8001c6a:	bf4c      	ite	mi
 8001c6c:	6006      	strmi	r6, [r0, #0]
; 	// compare value for logical 1
		}
		else
		{
			WS2812_IO_framedata[pwm_pos+j] = (uint32_t)(((uint32_t) 33 * (uwTimerPeriod - 1)) / 100);// compare value for logical 0
 8001c6e:	6004      	strpl	r4, [r0, #0]
		}

		if ( (color2<<j) & 0x80 )	// data sent MSB first, j = 0 is MSB j = 7 is LSB
 8001c70:	063f      	lsls	r7, r7, #24
		else
		{
			WS2812_IO_framedata[pwm_pos+8+j] = (uint32_t)(((uint32_t) 33 * (uwTimerPeriod - 1)) / 100);	// compare value for logical 0
		}

		if ( (color3<<j) & 0x80 )	// data sent MSB first, j = 0 is MSB j = 7 is LSB
 8001c72:	fa03 f705 	lsl.w	r7, r3, r5
			WS2812_IO_framedata[pwm_pos+j] = (uint32_t)(((uint32_t) 33 * (uwTimerPeriod - 1)) / 100);// compare value for logical 0
		}

		if ( (color2<<j) & 0x80 )	// data sent MSB first, j = 0 is MSB j = 7 is LSB
		{
			WS2812_IO_framedata[pwm_pos+8+j] = (uint32_t)(((uint32_t) 66 * (uwTimerPeriod - 1)) / 100); 	// compare value for logical 1
 8001c76:	bf4c      	ite	mi
 8001c78:	6206      	strmi	r6, [r0, #32]
		}
		else
		{
			WS2812_IO_framedata[pwm_pos+8+j] = (uint32_t)(((uint32_t) 33 * (uwTimerPeriod - 1)) / 100);	// compare value for logical 0
 8001c7a:	6204      	strpl	r4, [r0, #32]
		color2 = 255;
	if(color3 > 255)
		color3 = 255;


	for (j = 0; j < 8; j++)
 8001c7c:	3501      	adds	r5, #1
		else
		{
			WS2812_IO_framedata[pwm_pos+8+j] = (uint32_t)(((uint32_t) 33 * (uwTimerPeriod - 1)) / 100);	// compare value for logical 0
		}

		if ( (color3<<j) & 0x80 )	// data sent MSB first, j = 0 is MSB j = 7 is LSB
 8001c7e:	063f      	lsls	r7, r7, #24
		{
			WS2812_IO_framedata[pwm_pos+16+j] = (uint32_t)(((uint32_t) 66 * (uwTimerPeriod - 1)) / 100);	// compare value for logical 1   15
 8001c80:	bf4c      	ite	mi
 8001c82:	6406      	strmi	r6, [r0, #64]	; 0x40
		}
		else
		{
			WS2812_IO_framedata[pwm_pos+16+j] = (uint32_t)(((uint32_t) 33 * (uwTimerPeriod - 1)) / 100);	// compare value for logical 0     6
 8001c84:	6404      	strpl	r4, [r0, #64]	; 0x40
		color2 = 255;
	if(color3 > 255)
		color3 = 255;


	for (j = 0; j < 8; j++)
 8001c86:	2d08      	cmp	r5, #8
 8001c88:	f100 0004 	add.w	r0, r0, #4
 8001c8c:	d1e8      	bne.n	8001c60 <color2pwm+0x28>
		else
		{
			WS2812_IO_framedata[pwm_pos+16+j] = (uint32_t)(((uint32_t) 33 * (uwTimerPeriod - 1)) / 100);	// compare value for logical 0     6
		}
	}
}
 8001c8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001c90:	20000488 	.word	0x20000488
 8001c94:	200006e0 	.word	0x200006e0

08001c98 <charToNumJa>:

uint8_t charToNumJa(uint8_t ityChar[2])
{
	int cislo1;

	if (ityChar[0] < 'A')
 8001c98:	7803      	ldrb	r3, [r0, #0]
		cislo1 = (ityChar[0] - '0') * 16;
	else
		cislo1 = (ityChar[0] - 'A' + 10) * 16;

	if (ityChar[1] < 'A')
 8001c9a:	7840      	ldrb	r0, [r0, #1]

uint8_t charToNumJa(uint8_t ityChar[2])
{
	int cislo1;

	if (ityChar[0] < 'A')
 8001c9c:	2b40      	cmp	r3, #64	; 0x40
		cislo1 = (ityChar[0] - '0') * 16;
 8001c9e:	bf94      	ite	ls
 8001ca0:	3b30      	subls	r3, #48	; 0x30
	else
		cislo1 = (ityChar[0] - 'A' + 10) * 16;
 8001ca2:	3b37      	subhi	r3, #55	; 0x37

	if (ityChar[1] < 'A')
 8001ca4:	2840      	cmp	r0, #64	; 0x40
	int cislo1;

	if (ityChar[0] < 'A')
		cislo1 = (ityChar[0] - '0') * 16;
	else
		cislo1 = (ityChar[0] - 'A' + 10) * 16;
 8001ca6:	ea4f 1303 	mov.w	r3, r3, lsl #4

	if (ityChar[1] < 'A')
		cislo1 += (ityChar[1] - '0');
 8001caa:	bf94      	ite	ls
 8001cac:	3830      	subls	r0, #48	; 0x30
	else
		cislo1 += (ityChar[1] - 'A' + 10);
 8001cae:	3837      	subhi	r0, #55	; 0x37
 8001cb0:	4418      	add	r0, r3

	return cislo1;
}
 8001cb2:	b2c0      	uxtb	r0, r0
 8001cb4:	4770      	bx	lr
	...

08001cb8 <main>:
int main(void)
{
 8001cb8:	b530      	push	{r4, r5, lr}
 8001cba:	b095      	sub	sp, #84	; 0x54
         duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and 
         handled in milliseconds basis.
       - Set NVIC Group Priority to 4
       - Low Level Initialization
     */
  HAL_Init();
 8001cbc:	f7fe fb02 	bl	80002c4 <HAL_Init>

  /* Configure LED2 */
  BSP_LED_Init(LED2);
 8001cc0:	2000      	movs	r0, #0
 8001cc2:	f7fe fa5b 	bl	800017c <BSP_LED_Init>
  BSP_PB_Init(BUTTON_USER,BUTTON_MODE_EXTI);
 8001cc6:	2101      	movs	r1, #1
 8001cc8:	2000      	movs	r0, #0
 8001cca:	f7fe fa89 	bl	80001e0 <BSP_PB_Init>
  */


static void SystemClock_Config(void)
{
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8001cce:	2214      	movs	r2, #20
 8001cd0:	2100      	movs	r1, #0
 8001cd2:	a802      	add	r0, sp, #8
 8001cd4:	f000 fa6e 	bl	80021b4 <memset>
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8001cd8:	2234      	movs	r2, #52	; 0x34
 8001cda:	2100      	movs	r1, #0
 8001cdc:	a807      	add	r0, sp, #28
 8001cde:	f000 fa69 	bl	80021b4 <memset>

  /* Enable HSE Oscillator and Activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType      = RCC_OSCILLATORTYPE_HSI;
 8001ce2:	2302      	movs	r3, #2
  RCC_OscInitStruct.HSIState            = RCC_HSI_ON;
 8001ce4:	2201      	movs	r2, #1
{
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};

  /* Enable HSE Oscillator and Activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType      = RCC_OSCILLATORTYPE_HSI;
 8001ce6:	9307      	str	r3, [sp, #28]
  RCC_OscInitStruct.HSIState            = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState        = RCC_PLL_ON;
 8001ce8:	9310      	str	r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLSource       = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLMUL          = RCC_PLL_MUL6;
 8001cea:	f44f 2300 	mov.w	r3, #524288	; 0x80000
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};

  /* Enable HSE Oscillator and Activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType      = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState            = RCC_HSI_ON;
 8001cee:	920a      	str	r2, [sp, #40]	; 0x28
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState        = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource       = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLMUL          = RCC_PLL_MUL6;
 8001cf0:	9312      	str	r3, [sp, #72]	; 0x48
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};

  /* Enable HSE Oscillator and Activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType      = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState            = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8001cf2:	2210      	movs	r2, #16
  RCC_OscInitStruct.PLL.PLLState        = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource       = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLMUL          = RCC_PLL_MUL6;
  RCC_OscInitStruct.PLL.PLLDIV          = RCC_PLL_DIV3;
 8001cf4:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8001cf8:	a807      	add	r0, sp, #28
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};

  /* Enable HSE Oscillator and Activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType      = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState            = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8001cfa:	920b      	str	r2, [sp, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLState        = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource       = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLMUL          = RCC_PLL_MUL6;
  RCC_OscInitStruct.PLL.PLLDIV          = RCC_PLL_DIV3;
 8001cfc:	9313      	str	r3, [sp, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8001cfe:	f7fe fe3f 	bl	8000980 <HAL_RCC_OscConfig>
 8001d02:	b108      	cbz	r0, 8001d08 <main+0x50>
  {
    Error_Handler();
 8001d04:	f7ff ff89 	bl	8001c1a <Error_Handler>
  }

  /* Set Voltage scale1 as MCU will run at 32MHz */
  __HAL_RCC_PWR_CLK_ENABLE();
 8001d08:	4b4b      	ldr	r3, [pc, #300]	; (8001e38 <main+0x180>)
 8001d0a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001d0c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001d10:	625a      	str	r2, [r3, #36]	; 0x24
 8001d12:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001d14:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001d18:	9301      	str	r3, [sp, #4]
 8001d1a:	9b01      	ldr	r3, [sp, #4]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8001d1c:	4b47      	ldr	r3, [pc, #284]	; (8001e3c <main+0x184>)
 8001d1e:	681a      	ldr	r2, [r3, #0]
 8001d20:	f422 52c0 	bic.w	r2, r2, #6144	; 0x1800
 8001d24:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8001d28:	601a      	str	r2, [r3, #0]
 8001d2a:	461a      	mov	r2, r3
  
  /* Poll VOSF bit of in PWR_CSR. Wait until it is reset to 0 */
  while (__HAL_PWR_GET_FLAG(PWR_FLAG_VOS) != RESET) {};
 8001d2c:	6853      	ldr	r3, [r2, #4]
 8001d2e:	f013 0310 	ands.w	r3, r3, #16
 8001d32:	d1fb      	bne.n	8001d2c <main+0x74>

  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
  clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
 8001d34:	220f      	movs	r2, #15
 8001d36:	9202      	str	r2, [sp, #8]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8001d38:	2101      	movs	r1, #1
  while (__HAL_PWR_GET_FLAG(PWR_FLAG_VOS) != RESET) {};

  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
  clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8001d3a:	2203      	movs	r2, #3
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8001d3c:	a802      	add	r0, sp, #8
  while (__HAL_PWR_GET_FLAG(PWR_FLAG_VOS) != RESET) {};

  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
  clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8001d3e:	9203      	str	r2, [sp, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8001d40:	9304      	str	r3, [sp, #16]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8001d42:	9305      	str	r3, [sp, #20]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8001d44:	9306      	str	r3, [sp, #24]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8001d46:	f7ff f99f 	bl	8001088 <HAL_RCC_ClockConfig>
 8001d4a:	2800      	cmp	r0, #0
 8001d4c:	d1da      	bne.n	8001d04 <main+0x4c>

  /* Configure the system clock to 32 MHz */
  SystemClock_Config();

  /* Compute the value of ARR regiter to generate signal frequency at 17.57 Khz */
  uwTimerPeriod = (uint32_t)((SystemCoreClock / 800000) - 1);
 8001d4e:	4b3c      	ldr	r3, [pc, #240]	; (8001e40 <main+0x188>)
 8001d50:	4a3c      	ldr	r2, [pc, #240]	; (8001e44 <main+0x18c>)
 8001d52:	681b      	ldr	r3, [r3, #0]


  for(int i=0;i<(24*40+100);i++){

  		WS2812_IO_framedata[i]=(uint32_t)(((uint32_t) 33 * (uwTimerPeriod - 1)) / 100);
 8001d54:	2164      	movs	r1, #100	; 0x64

  /* Configure the system clock to 32 MHz */
  SystemClock_Config();

  /* Compute the value of ARR regiter to generate signal frequency at 17.57 Khz */
  uwTimerPeriod = (uint32_t)((SystemCoreClock / 800000) - 1);
 8001d56:	fbb3 f3f2 	udiv	r3, r3, r2
 8001d5a:	4a3b      	ldr	r2, [pc, #236]	; (8001e48 <main+0x190>)
 8001d5c:	3b01      	subs	r3, #1
 8001d5e:	6013      	str	r3, [r2, #0]
 8001d60:	4615      	mov	r5, r2


  for(int i=0;i<(24*40+100);i++){
 8001d62:	f240 4224 	movw	r2, #1060	; 0x424

  		WS2812_IO_framedata[i]=(uint32_t)(((uint32_t) 33 * (uwTimerPeriod - 1)) / 100);
 8001d66:	eb03 1343 	add.w	r3, r3, r3, lsl #5
 8001d6a:	3b21      	subs	r3, #33	; 0x21
 8001d6c:	fbb3 f3f1 	udiv	r3, r3, r1
 8001d70:	4936      	ldr	r1, [pc, #216]	; (8001e4c <main+0x194>)
 8001d72:	f841 3020 	str.w	r3, [r1, r0, lsl #2]

  /* Compute the value of ARR regiter to generate signal frequency at 17.57 Khz */
  uwTimerPeriod = (uint32_t)((SystemCoreClock / 800000) - 1);


  for(int i=0;i<(24*40+100);i++){
 8001d76:	3001      	adds	r0, #1
 8001d78:	4290      	cmp	r0, r2
 8001d7a:	d1fa      	bne.n	8001d72 <main+0xba>
 8001d7c:	4a34      	ldr	r2, [pc, #208]	; (8001e50 <main+0x198>)
  		WS2812_IO_framedata[i]=(uint32_t)(((uint32_t) 33 * (uwTimerPeriod - 1)) / 100);
  	}

  	  for(int i=0;i<100;i++){

  			WS2812_IO_framedata[24*40+i]=0;
 8001d7e:	2000      	movs	r0, #0
 8001d80:	f502 71c8 	add.w	r1, r2, #400	; 0x190
 8001d84:	f842 0f04 	str.w	r0, [r2, #4]!
  for(int i=0;i<(24*40+100);i++){

  		WS2812_IO_framedata[i]=(uint32_t)(((uint32_t) 33 * (uwTimerPeriod - 1)) / 100);
  	}

  	  for(int i=0;i<100;i++){
 8001d88:	428a      	cmp	r2, r1

  			WS2812_IO_framedata[24*40+i]=0;
 8001d8a:	f04f 0300 	mov.w	r3, #0
  for(int i=0;i<(24*40+100);i++){

  		WS2812_IO_framedata[i]=(uint32_t)(((uint32_t) 33 * (uwTimerPeriod - 1)) / 100);
  	}

  	  for(int i=0;i<100;i++){
 8001d8e:	d1f9      	bne.n	8001d84 <main+0xcc>
      + Period = TimerPeriod (To have an output frequency equal to 17.570 KHz)
      + Prescaler = 0
      + ClockDivision = 0
      + Counter direction = Up
  */
  	  UartHandle.Instance        = USARTx;
 8001d90:	4c30      	ldr	r4, [pc, #192]	; (8001e54 <main+0x19c>)

  	  UartHandle.Init.BaudRate   = 9600;
 8001d92:	4931      	ldr	r1, [pc, #196]	; (8001e58 <main+0x1a0>)
 8001d94:	f44f 5216 	mov.w	r2, #9600	; 0x2580
  	  UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 8001d98:	60a3      	str	r3, [r4, #8]
  	  UartHandle.Init.StopBits   = UART_STOPBITS_1;
 8001d9a:	60e3      	str	r3, [r4, #12]
  	  UartHandle.Init.Parity     = UART_PARITY_NONE;
 8001d9c:	6123      	str	r3, [r4, #16]
  	  UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
 8001d9e:	61a3      	str	r3, [r4, #24]
  	  UartHandle.Init.Mode       = UART_MODE_TX_RX;
  	  if(HAL_UART_DeInit(&UartHandle) != HAL_OK)
 8001da0:	4620      	mov	r0, r4
  	  UartHandle.Init.BaudRate   = 9600;
  	  UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
  	  UartHandle.Init.StopBits   = UART_STOPBITS_1;
  	  UartHandle.Init.Parity     = UART_PARITY_NONE;
  	  UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
  	  UartHandle.Init.Mode       = UART_MODE_TX_RX;
 8001da2:	230c      	movs	r3, #12
      + ClockDivision = 0
      + Counter direction = Up
  */
  	  UartHandle.Instance        = USARTx;

  	  UartHandle.Init.BaudRate   = 9600;
 8001da4:	e884 0006 	stmia.w	r4, {r1, r2}
  	  UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
  	  UartHandle.Init.StopBits   = UART_STOPBITS_1;
  	  UartHandle.Init.Parity     = UART_PARITY_NONE;
  	  UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
  	  UartHandle.Init.Mode       = UART_MODE_TX_RX;
 8001da8:	6163      	str	r3, [r4, #20]
  	  if(HAL_UART_DeInit(&UartHandle) != HAL_OK)
 8001daa:	f7ff fd69 	bl	8001880 <HAL_UART_DeInit>
 8001dae:	2800      	cmp	r0, #0
 8001db0:	d1a8      	bne.n	8001d04 <main+0x4c>
  	  {
  	    Error_Handler();
  	  }
  	  if(HAL_UART_Init(&UartHandle) != HAL_OK)
 8001db2:	4620      	mov	r0, r4
 8001db4:	f7ff fd38 	bl	8001828 <HAL_UART_Init>
 8001db8:	2800      	cmp	r0, #0
 8001dba:	d1a3      	bne.n	8001d04 <main+0x4c>
  	  {
  	    Error_Handler();
  	  }

  	  if(HAL_UART_Receive_DMA(&UartHandle, (uint8_t *)aRxBuffer, RXBUFFERSIZE1)!= HAL_OK)
 8001dbc:	22f0      	movs	r2, #240	; 0xf0
 8001dbe:	4927      	ldr	r1, [pc, #156]	; (8001e5c <main+0x1a4>)
 8001dc0:	4620      	mov	r0, r4
 8001dc2:	f7ff fdb9 	bl	8001938 <HAL_UART_Receive_DMA>
 8001dc6:	2800      	cmp	r0, #0
 8001dc8:	d19c      	bne.n	8001d04 <main+0x4c>
  	  }

  	  /*##-3- Start the transmission process #####################################*/
  	  /* While the UART in reception process, user can transmit data through
  	     "aTxBuffer" buffer */
  	  if(HAL_UART_Transmit_DMA(&UartHandle, (uint8_t*)aTxBuffer, TXBUFFERSIZE)!= HAL_OK)
 8001dca:	22f0      	movs	r2, #240	; 0xf0
 8001dcc:	4924      	ldr	r1, [pc, #144]	; (8001e60 <main+0x1a8>)
 8001dce:	4620      	mov	r0, r4
 8001dd0:	f7ff fd70 	bl	80018b4 <HAL_UART_Transmit_DMA>
 8001dd4:	2800      	cmp	r0, #0
 8001dd6:	d195      	bne.n	8001d04 <main+0x4c>
  	  {
  	    Error_Handler();
  	  }


  TimHandle.Instance = TIMx;
 8001dd8:	4c22      	ldr	r4, [pc, #136]	; (8001e64 <main+0x1ac>)
 8001dda:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001dde:	6023      	str	r3, [r4, #0]

  TimHandle.Init.Period            = uwTimerPeriod;
 8001de0:	682b      	ldr	r3, [r5, #0]
  TimHandle.Init.Prescaler         = 0;
 8001de2:	6060      	str	r0, [r4, #4]
  TimHandle.Init.ClockDivision     = 0;
 8001de4:	6120      	str	r0, [r4, #16]
  TimHandle.Init.CounterMode       = TIM_COUNTERMODE_UP;
 8001de6:	60a0      	str	r0, [r4, #8]
  if (HAL_TIM_PWM_Init(&TimHandle) != HAL_OK)
 8001de8:	4620      	mov	r0, r4
  	  }


  TimHandle.Instance = TIMx;

  TimHandle.Init.Period            = uwTimerPeriod;
 8001dea:	60e3      	str	r3, [r4, #12]
  TimHandle.Init.Prescaler         = 0;
  TimHandle.Init.ClockDivision     = 0;
  TimHandle.Init.CounterMode       = TIM_COUNTERMODE_UP;
  if (HAL_TIM_PWM_Init(&TimHandle) != HAL_OK)
 8001dec:	f7ff fac1 	bl	8001372 <HAL_TIM_PWM_Init>
 8001df0:	2800      	cmp	r0, #0
 8001df2:	d187      	bne.n	8001d04 <main+0x4c>
    /* Initialization Error */
    Error_Handler();
  }

  /*##-2- Configure the PWM channel 3 ########################################*/
  sConfig.OCMode       = TIM_OCMODE_PWM1;
 8001df4:	491c      	ldr	r1, [pc, #112]	; (8001e68 <main+0x1b0>)
 8001df6:	2360      	movs	r3, #96	; 0x60
 8001df8:	600b      	str	r3, [r1, #0]
  sConfig.OCPolarity   = TIM_OCPOLARITY_HIGH;
  sConfig.Pulse        = aCCValue_Buffer[0];
 8001dfa:	4b1c      	ldr	r3, [pc, #112]	; (8001e6c <main+0x1b4>)
    Error_Handler();
  }

  /*##-2- Configure the PWM channel 3 ########################################*/
  sConfig.OCMode       = TIM_OCMODE_PWM1;
  sConfig.OCPolarity   = TIM_OCPOLARITY_HIGH;
 8001dfc:	6088      	str	r0, [r1, #8]
  sConfig.Pulse        = aCCValue_Buffer[0];
 8001dfe:	681b      	ldr	r3, [r3, #0]
  if (HAL_TIM_PWM_ConfigChannel(&TimHandle, &sConfig, TIM_CHANNEL_3) != HAL_OK)
 8001e00:	2208      	movs	r2, #8
 8001e02:	4620      	mov	r0, r4
  }

  /*##-2- Configure the PWM channel 3 ########################################*/
  sConfig.OCMode       = TIM_OCMODE_PWM1;
  sConfig.OCPolarity   = TIM_OCPOLARITY_HIGH;
  sConfig.Pulse        = aCCValue_Buffer[0];
 8001e04:	604b      	str	r3, [r1, #4]
  if (HAL_TIM_PWM_ConfigChannel(&TimHandle, &sConfig, TIM_CHANNEL_3) != HAL_OK)
 8001e06:	f7ff fb39 	bl	800147c <HAL_TIM_PWM_ConfigChannel>
 8001e0a:	2800      	cmp	r0, #0
 8001e0c:	f47f af7a 	bne.w	8001d04 <main+0x4c>
    /* Configuration Error */
    Error_Handler();
  }

  /*##-3- Start PWM signal generation in DMA mode ############################*/
  if (HAL_TIM_PWM_Start_DMA(&TimHandle, TIM_CHANNEL_3, WS2812_IO_framedata, dlzka) != HAL_OK)
 8001e10:	4b17      	ldr	r3, [pc, #92]	; (8001e70 <main+0x1b8>)
 8001e12:	4a0e      	ldr	r2, [pc, #56]	; (8001e4c <main+0x194>)
 8001e14:	881b      	ldrh	r3, [r3, #0]
 8001e16:	2108      	movs	r1, #8
 8001e18:	4620      	mov	r0, r4
 8001e1a:	f7ff fac5 	bl	80013a8 <HAL_TIM_PWM_Start_DMA>
 8001e1e:	2800      	cmp	r0, #0
 8001e20:	f47f af70 	bne.w	8001d04 <main+0x4c>
    Error_Handler();
  }

  while (1)
  {
  Delay(500000L);
 8001e24:	4813      	ldr	r0, [pc, #76]	; (8001e74 <main+0x1bc>)
 8001e26:	f7ff fefd 	bl	8001c24 <Delay>
  aRxBuffer;
  HAL_UART_Receive_DMA(&UartHandle, (uint8_t *)aRxBuffer,RXBUFFERSIZE1 );
 8001e2a:	22f0      	movs	r2, #240	; 0xf0
 8001e2c:	490b      	ldr	r1, [pc, #44]	; (8001e5c <main+0x1a4>)
 8001e2e:	4809      	ldr	r0, [pc, #36]	; (8001e54 <main+0x19c>)
 8001e30:	f7ff fd82 	bl	8001938 <HAL_UART_Receive_DMA>
 8001e34:	e7f6      	b.n	8001e24 <main+0x16c>
 8001e36:	bf00      	nop
 8001e38:	40023800 	.word	0x40023800
 8001e3c:	40007000 	.word	0x40007000
 8001e40:	20000008 	.word	0x20000008
 8001e44:	000c3500 	.word	0x000c3500
 8001e48:	20000488 	.word	0x20000488
 8001e4c:	200006e0 	.word	0x200006e0
 8001e50:	200015dc 	.word	0x200015dc
 8001e54:	20000564 	.word	0x20000564
 8001e58:	40013800 	.word	0x40013800
 8001e5c:	200005b8 	.word	0x200005b8
 8001e60:	20000010 	.word	0x20000010
 8001e64:	200006a8 	.word	0x200006a8
 8001e68:	200005a4 	.word	0x200005a4
 8001e6c:	200000c8 	.word	0x200000c8
 8001e70:	2000000c 	.word	0x2000000c
 8001e74:	0007a120 	.word	0x0007a120

08001e78 <HAL_UART_RxCpltCallback>:
    Error_Handler();
  }
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *UartHandle)
{
 8001e78:	b530      	push	{r4, r5, lr}
  /* Set transmission flag: trasfer complete*/
  UartReady = SET;
 8001e7a:	4b18      	ldr	r3, [pc, #96]	; (8001edc <HAL_UART_RxCpltCallback+0x64>)
    Error_Handler();
  }
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *UartHandle)
{
 8001e7c:	b087      	sub	sp, #28
  /* Set transmission flag: trasfer complete*/
  UartReady = SET;
 8001e7e:	2201      	movs	r2, #1
 8001e80:	4c17      	ldr	r4, [pc, #92]	; (8001ee0 <HAL_UART_RxCpltCallback+0x68>)
    Error_Handler();
  }
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *UartHandle)
{
 8001e82:	9001      	str	r0, [sp, #4]
  /* Set transmission flag: trasfer complete*/
  UartReady = SET;
 8001e84:	701a      	strb	r2, [r3, #0]
      	uint8_t ulzene3[2];


      		//uint8_t aRxBuffer[10]="00FFFF";

      		for(int i=0;i<40;i ++){
 8001e86:	2500      	movs	r5, #0
      		         	    	 		strncpy(ulzene1, aRxBuffer + i*6, 2);
 8001e88:	1ea1      	subs	r1, r4, #2
 8001e8a:	2202      	movs	r2, #2
 8001e8c:	a803      	add	r0, sp, #12
 8001e8e:	f000 f999 	bl	80021c4 <strncpy>
      		         	    	 		strncpy(ulzene2, aRxBuffer + (i*6 + 2), 2);
 8001e92:	4621      	mov	r1, r4
 8001e94:	2202      	movs	r2, #2
 8001e96:	a804      	add	r0, sp, #16
 8001e98:	f000 f994 	bl	80021c4 <strncpy>
      		         	    	 		strncpy(ulzene3, aRxBuffer + (i*6 + 4), 2);
 8001e9c:	2202      	movs	r2, #2
 8001e9e:	18a1      	adds	r1, r4, r2
 8001ea0:	a805      	add	r0, sp, #20
 8001ea2:	f000 f98f 	bl	80021c4 <strncpy>

      		         	    	 		color2pwm(i, charToNumJa(ulzene2), charToNumJa(ulzene1), charToNumJa(ulzene3));
 8001ea6:	a804      	add	r0, sp, #16
 8001ea8:	f7ff fef6 	bl	8001c98 <charToNumJa>
 8001eac:	4601      	mov	r1, r0
 8001eae:	a803      	add	r0, sp, #12
 8001eb0:	f7ff fef2 	bl	8001c98 <charToNumJa>
 8001eb4:	4602      	mov	r2, r0
 8001eb6:	a805      	add	r0, sp, #20
 8001eb8:	f7ff feee 	bl	8001c98 <charToNumJa>
 8001ebc:	4603      	mov	r3, r0
 8001ebe:	4628      	mov	r0, r5
      	uint8_t ulzene3[2];


      		//uint8_t aRxBuffer[10]="00FFFF";

      		for(int i=0;i<40;i ++){
 8001ec0:	3501      	adds	r5, #1
      		         	    	 		strncpy(ulzene1, aRxBuffer + i*6, 2);
      		         	    	 		strncpy(ulzene2, aRxBuffer + (i*6 + 2), 2);
      		         	    	 		strncpy(ulzene3, aRxBuffer + (i*6 + 4), 2);

      		         	    	 		color2pwm(i, charToNumJa(ulzene2), charToNumJa(ulzene1), charToNumJa(ulzene3));
 8001ec2:	f7ff feb9 	bl	8001c38 <color2pwm>
      	uint8_t ulzene3[2];


      		//uint8_t aRxBuffer[10]="00FFFF";

      		for(int i=0;i<40;i ++){
 8001ec6:	2d28      	cmp	r5, #40	; 0x28
 8001ec8:	f104 0406 	add.w	r4, r4, #6
 8001ecc:	d1dc      	bne.n	8001e88 <HAL_UART_RxCpltCallback+0x10>
      		         	    	 		strncpy(ulzene3, aRxBuffer + (i*6 + 4), 2);

      		         	    	 		color2pwm(i, charToNumJa(ulzene2), charToNumJa(ulzene1), charToNumJa(ulzene3));
      		         	    	 		//color2pwm(i, colors[11][0], colors[11][1], colors[11][2]);
      		         	    	 	}
      		  HAL_UART_Receive_DMA(&UartHandle, (uint8_t *)aRxBuffer,RXBUFFERSIZE1 );
 8001ece:	22f0      	movs	r2, #240	; 0xf0
 8001ed0:	4904      	ldr	r1, [pc, #16]	; (8001ee4 <HAL_UART_RxCpltCallback+0x6c>)
 8001ed2:	a801      	add	r0, sp, #4
 8001ed4:	f7ff fd30 	bl	8001938 <HAL_UART_Receive_DMA>

      		  //USART1->DR &= ~(0b111111111<<(32-9));
      		  //__HAL_UART_FLUSH_DRREGISTER(&UartHandle);
}
 8001ed8:	b007      	add	sp, #28
 8001eda:	bd30      	pop	{r4, r5, pc}
 8001edc:	2000048c 	.word	0x2000048c
 8001ee0:	200005ba 	.word	0x200005ba
 8001ee4:	200005b8 	.word	0x200005b8

08001ee8 <HAL_UART_ErrorCallback>:
  * @note   This example shows a simple way to report transfer error, and you can
  *         add your own implementation.
  * @retval None
  */
void HAL_UART_ErrorCallback(UART_HandleTypeDef *UartHandle)
{
 8001ee8:	b508      	push	{r3, lr}
    Error_Handler();
 8001eea:	f7ff fe96 	bl	8001c1a <Error_Handler>
	...

08001ef0 <HAL_GPIO_EXTI_Callback>:
  * @param GPIO_Pin: Specifies the pins connected EXTI line
  * @retval None
  */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  if(GPIO_Pin == USER_BUTTON_PIN)
 8001ef0:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
  {
    UserButtonStatus = 1;
 8001ef4:	bf02      	ittt	eq
 8001ef6:	4b02      	ldreq	r3, [pc, #8]	; (8001f00 <HAL_GPIO_EXTI_Callback+0x10>)
 8001ef8:	2201      	moveq	r2, #1
 8001efa:	601a      	streq	r2, [r3, #0]
 8001efc:	4770      	bx	lr
 8001efe:	bf00      	nop
 8001f00:	20000490 	.word	0x20000490

08001f04 <HAL_TIM_PWM_MspInit>:
  GPIO_InitTypeDef   GPIO_InitStruct;
  static DMA_HandleTypeDef  hdma_tim;

  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* TIMx clock enable */
  TIMx_CLK_ENABLE();
 8001f04:	4b27      	ldr	r3, [pc, #156]	; (8001fa4 <HAL_TIM_PWM_MspInit+0xa0>)
  *           - DMA configuration for transmission request by peripheral
  * @param htim: TIM handle pointer
  * @retval None
  */
void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
{
 8001f06:	b530      	push	{r4, r5, lr}
  GPIO_InitTypeDef   GPIO_InitStruct;
  static DMA_HandleTypeDef  hdma_tim;

  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* TIMx clock enable */
  TIMx_CLK_ENABLE();
 8001f08:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  *           - DMA configuration for transmission request by peripheral
  * @param htim: TIM handle pointer
  * @retval None
  */
void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
{
 8001f0a:	4604      	mov	r4, r0
  GPIO_InitTypeDef   GPIO_InitStruct;
  static DMA_HandleTypeDef  hdma_tim;

  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* TIMx clock enable */
  TIMx_CLK_ENABLE();
 8001f0c:	f042 0201 	orr.w	r2, r2, #1
 8001f10:	625a      	str	r2, [r3, #36]	; 0x24
 8001f12:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  *           - DMA configuration for transmission request by peripheral
  * @param htim: TIM handle pointer
  * @retval None
  */
void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
{
 8001f14:	b089      	sub	sp, #36	; 0x24
  GPIO_InitTypeDef   GPIO_InitStruct;
  static DMA_HandleTypeDef  hdma_tim;

  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* TIMx clock enable */
  TIMx_CLK_ENABLE();
 8001f16:	f002 0201 	and.w	r2, r2, #1
 8001f1a:	9200      	str	r2, [sp, #0]
 8001f1c:	9a00      	ldr	r2, [sp, #0]

  /* Enable GPIO Channel3/3N Clocks */
  TIMx_CHANNEL3_GPIO_CLK_ENABLE();
 8001f1e:	69da      	ldr	r2, [r3, #28]
  GPIO_InitStruct.Pin = GPIO_PIN_CHANNEL3;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = GPIO_AF_TIMx;
  HAL_GPIO_Init(TIMx_GPIO_CHANNEL3_PORT, &GPIO_InitStruct);
 8001f20:	a903      	add	r1, sp, #12
  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* TIMx clock enable */
  TIMx_CLK_ENABLE();

  /* Enable GPIO Channel3/3N Clocks */
  TIMx_CHANNEL3_GPIO_CLK_ENABLE();
 8001f22:	f042 0202 	orr.w	r2, r2, #2
 8001f26:	61da      	str	r2, [r3, #28]
 8001f28:	69da      	ldr	r2, [r3, #28]
  GPIO_InitStruct.Pin = GPIO_PIN_CHANNEL3;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = GPIO_AF_TIMx;
  HAL_GPIO_Init(TIMx_GPIO_CHANNEL3_PORT, &GPIO_InitStruct);
 8001f2a:	481f      	ldr	r0, [pc, #124]	; (8001fa8 <HAL_TIM_PWM_MspInit+0xa4>)
  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* TIMx clock enable */
  TIMx_CLK_ENABLE();

  /* Enable GPIO Channel3/3N Clocks */
  TIMx_CHANNEL3_GPIO_CLK_ENABLE();
 8001f2c:	f002 0202 	and.w	r2, r2, #2
 8001f30:	9201      	str	r2, [sp, #4]
 8001f32:	9a01      	ldr	r2, [sp, #4]

  /* Enable DMA clock */
  DMAx_CLK_ENABLE();
 8001f34:	69da      	ldr	r2, [r3, #28]
  HAL_GPIO_Init(TIMx_GPIO_CHANNEL3_PORT, &GPIO_InitStruct);


  /* Set the parameters to be configured */
  hdma_tim.Init.Direction = DMA_MEMORY_TO_PERIPH;
  hdma_tim.Init.PeriphInc = DMA_PINC_DISABLE;
 8001f36:	2500      	movs	r5, #0

  /* Enable GPIO Channel3/3N Clocks */
  TIMx_CHANNEL3_GPIO_CLK_ENABLE();

  /* Enable DMA clock */
  DMAx_CLK_ENABLE();
 8001f38:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8001f3c:	61da      	str	r2, [r3, #28]
 8001f3e:	69db      	ldr	r3, [r3, #28]

  /* Configure TIM2_Channel3 in output, push-pull & alternate function mode */
  GPIO_InitStruct.Pin = GPIO_PIN_CHANNEL3;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001f40:	2203      	movs	r2, #3

  /* Enable GPIO Channel3/3N Clocks */
  TIMx_CHANNEL3_GPIO_CLK_ENABLE();

  /* Enable DMA clock */
  DMAx_CLK_ENABLE();
 8001f42:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8001f46:	9302      	str	r3, [sp, #8]
 8001f48:	9b02      	ldr	r3, [sp, #8]


  /* Configure TIM2_Channel3 in output, push-pull & alternate function mode */
  GPIO_InitStruct.Pin = GPIO_PIN_CHANNEL3;
 8001f4a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001f4e:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001f50:	2302      	movs	r3, #2
 8001f52:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8001f54:	2301      	movs	r3, #1
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001f56:	9206      	str	r2, [sp, #24]


  /* Configure TIM2_Channel3 in output, push-pull & alternate function mode */
  GPIO_InitStruct.Pin = GPIO_PIN_CHANNEL3;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8001f58:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = GPIO_AF_TIMx;
 8001f5a:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(TIMx_GPIO_CHANNEL3_PORT, &GPIO_InitStruct);
 8001f5c:	f7fe fb54 	bl	8000608 <HAL_GPIO_Init>


  /* Set the parameters to be configured */
  hdma_tim.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8001f60:	4812      	ldr	r0, [pc, #72]	; (8001fac <HAL_TIM_PWM_MspInit+0xa8>)
 8001f62:	2310      	movs	r3, #16
 8001f64:	6043      	str	r3, [r0, #4]
  hdma_tim.Init.PeriphInc = DMA_PINC_DISABLE;
  hdma_tim.Init.MemInc = DMA_MINC_ENABLE;
 8001f66:	2380      	movs	r3, #128	; 0x80
 8001f68:	60c3      	str	r3, [r0, #12]
  hdma_tim.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD ;
 8001f6a:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001f6e:	6103      	str	r3, [r0, #16]
  hdma_tim.Init.MemDataAlignment = DMA_MDATAALIGN_WORD ;
 8001f70:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001f74:	6143      	str	r3, [r0, #20]
  hdma_tim.Init.Mode = DMA_CIRCULAR;
 8001f76:	2320      	movs	r3, #32
 8001f78:	6183      	str	r3, [r0, #24]
  hdma_tim.Init.Priority = DMA_PRIORITY_HIGH;
 8001f7a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001f7e:	61c3      	str	r3, [r0, #28]

  /* Set hdma_tim instance */
  hdma_tim.Instance = TIMx_CC3_DMA_INST;
 8001f80:	4b0b      	ldr	r3, [pc, #44]	; (8001fb0 <HAL_TIM_PWM_MspInit+0xac>)

  /* Link hdma_tim to hdma[TIM_DMA_ID_CC3] (channel3) */
  __HAL_LINKDMA(htim, hdma[TIM_DMA_ID_CC3], hdma_tim);
 8001f82:	6260      	str	r0, [r4, #36]	; 0x24
  hdma_tim.Init.MemDataAlignment = DMA_MDATAALIGN_WORD ;
  hdma_tim.Init.Mode = DMA_CIRCULAR;
  hdma_tim.Init.Priority = DMA_PRIORITY_HIGH;

  /* Set hdma_tim instance */
  hdma_tim.Instance = TIMx_CC3_DMA_INST;
 8001f84:	6003      	str	r3, [r0, #0]
  HAL_GPIO_Init(TIMx_GPIO_CHANNEL3_PORT, &GPIO_InitStruct);


  /* Set the parameters to be configured */
  hdma_tim.Init.Direction = DMA_MEMORY_TO_PERIPH;
  hdma_tim.Init.PeriphInc = DMA_PINC_DISABLE;
 8001f86:	6085      	str	r5, [r0, #8]

  /* Set hdma_tim instance */
  hdma_tim.Instance = TIMx_CC3_DMA_INST;

  /* Link hdma_tim to hdma[TIM_DMA_ID_CC3] (channel3) */
  __HAL_LINKDMA(htim, hdma[TIM_DMA_ID_CC3], hdma_tim);
 8001f88:	6244      	str	r4, [r0, #36]	; 0x24

  /* Initialize TIMx DMA handle */
  HAL_DMA_Init(htim->hdma[TIM_DMA_ID_CC3]);
 8001f8a:	f7fe fa35 	bl	80003f8 <HAL_DMA_Init>

  /*##-2- Configure the NVIC for DMA #########################################*/
  /* NVIC configuration for DMA transfer complete interrupt */
  HAL_NVIC_SetPriority(TIMx_DMA_IRQn, 0, 0);
 8001f8e:	462a      	mov	r2, r5
 8001f90:	4629      	mov	r1, r5
 8001f92:	200b      	movs	r0, #11
 8001f94:	f7fe f9cc 	bl	8000330 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIMx_DMA_IRQn);
 8001f98:	200b      	movs	r0, #11
 8001f9a:	f7fe f9fd 	bl	8000398 <HAL_NVIC_EnableIRQ>
}
 8001f9e:	b009      	add	sp, #36	; 0x24
 8001fa0:	bd30      	pop	{r4, r5, pc}
 8001fa2:	bf00      	nop
 8001fa4:	40023800 	.word	0x40023800
 8001fa8:	40020400 	.word	0x40020400
 8001fac:	20000494 	.word	0x20000494
 8001fb0:	40026008 	.word	0x40026008

08001fb4 <HAL_UART_MspInit>:

  GPIO_InitTypeDef  GPIO_InitStruct;

  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* Enable GPIO TX/RX clock */
  USARTx_TX_GPIO_CLK_ENABLE();
 8001fb4:	4b3f      	ldr	r3, [pc, #252]	; (80020b4 <HAL_UART_MspInit+0x100>)
  *           - NVIC configuration for DMA interrupt request enable
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 8001fb6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  GPIO_InitTypeDef  GPIO_InitStruct;

  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* Enable GPIO TX/RX clock */
  USARTx_TX_GPIO_CLK_ENABLE();
 8001fba:	69da      	ldr	r2, [r3, #28]
  *           - NVIC configuration for DMA interrupt request enable
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 8001fbc:	b08a      	sub	sp, #40	; 0x28

  GPIO_InitTypeDef  GPIO_InitStruct;

  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* Enable GPIO TX/RX clock */
  USARTx_TX_GPIO_CLK_ENABLE();
 8001fbe:	f042 0202 	orr.w	r2, r2, #2
 8001fc2:	61da      	str	r2, [r3, #28]
 8001fc4:	69da      	ldr	r2, [r3, #28]
  *           - NVIC configuration for DMA interrupt request enable
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 8001fc6:	4606      	mov	r6, r0

  GPIO_InitTypeDef  GPIO_InitStruct;

  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* Enable GPIO TX/RX clock */
  USARTx_TX_GPIO_CLK_ENABLE();
 8001fc8:	f002 0202 	and.w	r2, r2, #2
 8001fcc:	9201      	str	r2, [sp, #4]
 8001fce:	9a01      	ldr	r2, [sp, #4]
  USARTx_RX_GPIO_CLK_ENABLE();
 8001fd0:	69da      	ldr	r2, [r3, #28]
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = USARTx_TX_AF;

  HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);
 8001fd2:	4c39      	ldr	r4, [pc, #228]	; (80020b8 <HAL_UART_MspInit+0x104>)
  GPIO_InitTypeDef  GPIO_InitStruct;

  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* Enable GPIO TX/RX clock */
  USARTx_TX_GPIO_CLK_ENABLE();
  USARTx_RX_GPIO_CLK_ENABLE();
 8001fd4:	f042 0202 	orr.w	r2, r2, #2
 8001fd8:	61da      	str	r2, [r3, #28]
 8001fda:	69da      	ldr	r2, [r3, #28]

  /*##-2- Configure peripheral GPIO ##########################################*/
  /* UART TX GPIO pin configuration  */
  GPIO_InitStruct.Pin       = USARTx_TX_PIN;
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
 8001fdc:	2701      	movs	r7, #1
  GPIO_InitTypeDef  GPIO_InitStruct;

  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* Enable GPIO TX/RX clock */
  USARTx_TX_GPIO_CLK_ENABLE();
  USARTx_RX_GPIO_CLK_ENABLE();
 8001fde:	f002 0202 	and.w	r2, r2, #2
 8001fe2:	9202      	str	r2, [sp, #8]
 8001fe4:	9a02      	ldr	r2, [sp, #8]


  /* Enable USARTx clock */
  USARTx_CLK_ENABLE();
 8001fe6:	6a1a      	ldr	r2, [r3, #32]
  /* UART TX GPIO pin configuration  */
  GPIO_InitStruct.Pin       = USARTx_TX_PIN;
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = USARTx_TX_AF;
 8001fe8:	2507      	movs	r5, #7
  USARTx_TX_GPIO_CLK_ENABLE();
  USARTx_RX_GPIO_CLK_ENABLE();


  /* Enable USARTx clock */
  USARTx_CLK_ENABLE();
 8001fea:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001fee:	621a      	str	r2, [r3, #32]
 8001ff0:	6a1a      	ldr	r2, [r3, #32]
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = USARTx_TX_AF;

  HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);
 8001ff2:	a905      	add	r1, sp, #20
  USARTx_TX_GPIO_CLK_ENABLE();
  USARTx_RX_GPIO_CLK_ENABLE();


  /* Enable USARTx clock */
  USARTx_CLK_ENABLE();
 8001ff4:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 8001ff8:	9203      	str	r2, [sp, #12]
 8001ffa:	9a03      	ldr	r2, [sp, #12]

  /* Enable DMA clock */
  DMAx_CLK_ENABLE();
 8001ffc:	69da      	ldr	r2, [r3, #28]
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = USARTx_TX_AF;

  HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);
 8001ffe:	4620      	mov	r0, r4

  /* Enable USARTx clock */
  USARTx_CLK_ENABLE();

  /* Enable DMA clock */
  DMAx_CLK_ENABLE();
 8002000:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8002004:	61da      	str	r2, [r3, #28]
 8002006:	69db      	ldr	r3, [r3, #28]
  GPIO_InitStruct.Alternate = USARTx_TX_AF;

  HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);

  /* UART RX GPIO pin configuration  */
  GPIO_InitStruct.Pin = USARTx_RX_PIN;
 8002008:	f04f 0880 	mov.w	r8, #128	; 0x80

  /* Enable USARTx clock */
  USARTx_CLK_ENABLE();

  /* Enable DMA clock */
  DMAx_CLK_ENABLE();
 800200c:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8002010:	9304      	str	r3, [sp, #16]
 8002012:	9b04      	ldr	r3, [sp, #16]

  /*##-2- Configure peripheral GPIO ##########################################*/
  /* UART TX GPIO pin configuration  */
  GPIO_InitStruct.Pin       = USARTx_TX_PIN;
 8002014:	2340      	movs	r3, #64	; 0x40
 8002016:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 8002018:	2302      	movs	r3, #2
 800201a:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
 800201c:	2303      	movs	r3, #3
 800201e:	9308      	str	r3, [sp, #32]
  GPIO_InitStruct.Alternate = USARTx_TX_AF;
 8002020:	9509      	str	r5, [sp, #36]	; 0x24

  /*##-2- Configure peripheral GPIO ##########################################*/
  /* UART TX GPIO pin configuration  */
  GPIO_InitStruct.Pin       = USARTx_TX_PIN;
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
 8002022:	9707      	str	r7, [sp, #28]
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = USARTx_TX_AF;

  HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);
 8002024:	f7fe faf0 	bl	8000608 <HAL_GPIO_Init>

  /* UART RX GPIO pin configuration  */
  GPIO_InitStruct.Pin = USARTx_RX_PIN;
  GPIO_InitStruct.Alternate = USARTx_RX_AF;

  HAL_GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStruct);
 8002028:	a905      	add	r1, sp, #20

  HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);

  /* UART RX GPIO pin configuration  */
  GPIO_InitStruct.Pin = USARTx_RX_PIN;
  GPIO_InitStruct.Alternate = USARTx_RX_AF;
 800202a:	9509      	str	r5, [sp, #36]	; 0x24

  HAL_GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStruct);
 800202c:	4620      	mov	r0, r4

  /*##-3- Configure the DMA ##################################################*/
  /* Configure the DMA handler for Transmission process */
  hdma_tx.Instance                 = USARTx_TX_DMA_CHANNEL;
 800202e:	4d23      	ldr	r5, [pc, #140]	; (80020bc <HAL_UART_MspInit+0x108>)
  GPIO_InitStruct.Alternate = USARTx_TX_AF;

  HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);

  /* UART RX GPIO pin configuration  */
  GPIO_InitStruct.Pin = USARTx_RX_PIN;
 8002030:	f8cd 8014 	str.w	r8, [sp, #20]
  GPIO_InitStruct.Alternate = USARTx_RX_AF;

  HAL_GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStruct);
 8002034:	f7fe fae8 	bl	8000608 <HAL_GPIO_Init>

  /*##-3- Configure the DMA ##################################################*/
  /* Configure the DMA handler for Transmission process */
  hdma_tx.Instance                 = USARTx_TX_DMA_CHANNEL;
  hdma_tx.Init.Direction           = DMA_MEMORY_TO_PERIPH;
  hdma_tx.Init.PeriphInc           = DMA_PINC_DISABLE;
 8002038:	4a21      	ldr	r2, [pc, #132]	; (80020c0 <HAL_UART_MspInit+0x10c>)
 800203a:	2400      	movs	r4, #0
 800203c:	2310      	movs	r3, #16
  hdma_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
  hdma_tx.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
  hdma_tx.Init.Mode                = DMA_NORMAL;
  hdma_tx.Init.Priority            = DMA_PRIORITY_LOW;

  HAL_DMA_Init(&hdma_tx);
 800203e:	4628      	mov	r0, r5

  /*##-3- Configure the DMA ##################################################*/
  /* Configure the DMA handler for Transmission process */
  hdma_tx.Instance                 = USARTx_TX_DMA_CHANNEL;
  hdma_tx.Init.Direction           = DMA_MEMORY_TO_PERIPH;
  hdma_tx.Init.PeriphInc           = DMA_PINC_DISABLE;
 8002040:	e885 001c 	stmia.w	r5, {r2, r3, r4}
  hdma_tx.Init.MemInc              = DMA_MINC_ENABLE;
 8002044:	f8c5 800c 	str.w	r8, [r5, #12]
  hdma_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8002048:	612c      	str	r4, [r5, #16]
  hdma_tx.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
 800204a:	616c      	str	r4, [r5, #20]
  hdma_tx.Init.Mode                = DMA_NORMAL;
 800204c:	61ac      	str	r4, [r5, #24]
  hdma_tx.Init.Priority            = DMA_PRIORITY_LOW;
 800204e:	61ec      	str	r4, [r5, #28]

  HAL_DMA_Init(&hdma_tx);
 8002050:	f7fe f9d2 	bl	80003f8 <HAL_DMA_Init>

  /* Associate the initialized DMA handle to the UART handle */
  __HAL_LINKDMA(huart, hdmatx, hdma_tx);
 8002054:	6335      	str	r5, [r6, #48]	; 0x30
 8002056:	626e      	str	r6, [r5, #36]	; 0x24

  /* Configure the DMA handler for reception process */
  hdma_rx.Instance                 = USARTx_RX_DMA_CHANNEL;
 8002058:	4b1a      	ldr	r3, [pc, #104]	; (80020c4 <HAL_UART_MspInit+0x110>)
 800205a:	4d1b      	ldr	r5, [pc, #108]	; (80020c8 <HAL_UART_MspInit+0x114>)
  hdma_rx.Init.Direction           = DMA_PERIPH_TO_MEMORY;
 800205c:	e885 0018 	stmia.w	r5, {r3, r4}
  hdma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
  hdma_rx.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
  hdma_rx.Init.Mode                = DMA_NORMAL;
  hdma_rx.Init.Priority            = DMA_PRIORITY_HIGH;

  HAL_DMA_Init(&hdma_rx);
 8002060:	4628      	mov	r0, r5
  hdma_rx.Init.PeriphInc           = DMA_PINC_DISABLE;
  hdma_rx.Init.MemInc              = DMA_MINC_ENABLE;
  hdma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
  hdma_rx.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
  hdma_rx.Init.Mode                = DMA_NORMAL;
  hdma_rx.Init.Priority            = DMA_PRIORITY_HIGH;
 8002062:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8002066:	61eb      	str	r3, [r5, #28]
  __HAL_LINKDMA(huart, hdmatx, hdma_tx);

  /* Configure the DMA handler for reception process */
  hdma_rx.Instance                 = USARTx_RX_DMA_CHANNEL;
  hdma_rx.Init.Direction           = DMA_PERIPH_TO_MEMORY;
  hdma_rx.Init.PeriphInc           = DMA_PINC_DISABLE;
 8002068:	60ac      	str	r4, [r5, #8]
  hdma_rx.Init.MemInc              = DMA_MINC_ENABLE;
 800206a:	f8c5 800c 	str.w	r8, [r5, #12]
  hdma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 800206e:	612c      	str	r4, [r5, #16]
  hdma_rx.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
 8002070:	616c      	str	r4, [r5, #20]
  hdma_rx.Init.Mode                = DMA_NORMAL;
 8002072:	61ac      	str	r4, [r5, #24]
  hdma_rx.Init.Priority            = DMA_PRIORITY_HIGH;

  HAL_DMA_Init(&hdma_rx);
 8002074:	f7fe f9c0 	bl	80003f8 <HAL_DMA_Init>
  /* Associate the initialized DMA handle to the the UART handle */
  __HAL_LINKDMA(huart, hdmarx, hdma_rx);

  /*##-4- Configure the NVIC for DMA #########################################*/
  /* NVIC configuration for DMA transfer complete interrupt (USART1_TX) */
  HAL_NVIC_SetPriority(USARTx_DMA_TX_IRQn, 0, 1);
 8002078:	463a      	mov	r2, r7
 800207a:	4621      	mov	r1, r4
  hdma_rx.Init.Priority            = DMA_PRIORITY_HIGH;

  HAL_DMA_Init(&hdma_rx);

  /* Associate the initialized DMA handle to the the UART handle */
  __HAL_LINKDMA(huart, hdmarx, hdma_rx);
 800207c:	6375      	str	r5, [r6, #52]	; 0x34

  /*##-4- Configure the NVIC for DMA #########################################*/
  /* NVIC configuration for DMA transfer complete interrupt (USART1_TX) */
  HAL_NVIC_SetPriority(USARTx_DMA_TX_IRQn, 0, 1);
 800207e:	200e      	movs	r0, #14
  hdma_rx.Init.Priority            = DMA_PRIORITY_HIGH;

  HAL_DMA_Init(&hdma_rx);

  /* Associate the initialized DMA handle to the the UART handle */
  __HAL_LINKDMA(huart, hdmarx, hdma_rx);
 8002080:	626e      	str	r6, [r5, #36]	; 0x24

  /*##-4- Configure the NVIC for DMA #########################################*/
  /* NVIC configuration for DMA transfer complete interrupt (USART1_TX) */
  HAL_NVIC_SetPriority(USARTx_DMA_TX_IRQn, 0, 1);
 8002082:	f7fe f955 	bl	8000330 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(USARTx_DMA_TX_IRQn);
 8002086:	200e      	movs	r0, #14
 8002088:	f7fe f986 	bl	8000398 <HAL_NVIC_EnableIRQ>

  /* NVIC configuration for DMA transfer complete interrupt (USART1_RX) */
  HAL_NVIC_SetPriority(USARTx_DMA_RX_IRQn, 0, 0);
 800208c:	4622      	mov	r2, r4
 800208e:	4621      	mov	r1, r4
 8002090:	200f      	movs	r0, #15
 8002092:	f7fe f94d 	bl	8000330 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(USARTx_DMA_RX_IRQn);
 8002096:	200f      	movs	r0, #15
 8002098:	f7fe f97e 	bl	8000398 <HAL_NVIC_EnableIRQ>

  /* NVIC for USART, to catch the TX complete */
  HAL_NVIC_SetPriority(USARTx_IRQn, 0, 1);
 800209c:	463a      	mov	r2, r7
 800209e:	4621      	mov	r1, r4
 80020a0:	2025      	movs	r0, #37	; 0x25
 80020a2:	f7fe f945 	bl	8000330 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(USARTx_IRQn);
 80020a6:	2025      	movs	r0, #37	; 0x25
 80020a8:	f7fe f976 	bl	8000398 <HAL_NVIC_EnableIRQ>
}
 80020ac:	b00a      	add	sp, #40	; 0x28
 80020ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80020b2:	bf00      	nop
 80020b4:	40023800 	.word	0x40023800
 80020b8:	40020400 	.word	0x40020400
 80020bc:	200004d8 	.word	0x200004d8
 80020c0:	40026044 	.word	0x40026044
 80020c4:	40026058 	.word	0x40026058
 80020c8:	2000051c 	.word	0x2000051c

080020cc <HAL_UART_MspDeInit>:
  *          - Revert GPIO, DMA and NVIC configuration to their default state
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
{
 80020cc:	b510      	push	{r4, lr}
 80020ce:	4604      	mov	r4, r0

  /*##-1- Reset peripherals ##################################################*/
  USARTx_FORCE_RESET();
 80020d0:	4b10      	ldr	r3, [pc, #64]	; (8002114 <HAL_UART_MspDeInit+0x48>)
  USARTx_RELEASE_RESET();

  /*##-2- Disable peripherals and GPIO Clocks #################################*/
  /* Configure USARTx Tx as alternate function  */
  HAL_GPIO_DeInit(USARTx_TX_GPIO_PORT, USARTx_TX_PIN);
 80020d2:	2140      	movs	r1, #64	; 0x40
  */
void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
{

  /*##-1- Reset peripherals ##################################################*/
  USARTx_FORCE_RESET();
 80020d4:	695a      	ldr	r2, [r3, #20]
  USARTx_RELEASE_RESET();

  /*##-2- Disable peripherals and GPIO Clocks #################################*/
  /* Configure USARTx Tx as alternate function  */
  HAL_GPIO_DeInit(USARTx_TX_GPIO_PORT, USARTx_TX_PIN);
 80020d6:	4810      	ldr	r0, [pc, #64]	; (8002118 <HAL_UART_MspDeInit+0x4c>)
  */
void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
{

  /*##-1- Reset peripherals ##################################################*/
  USARTx_FORCE_RESET();
 80020d8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80020dc:	615a      	str	r2, [r3, #20]
  USARTx_RELEASE_RESET();
 80020de:	695a      	ldr	r2, [r3, #20]
 80020e0:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 80020e4:	615a      	str	r2, [r3, #20]

  /*##-2- Disable peripherals and GPIO Clocks #################################*/
  /* Configure USARTx Tx as alternate function  */
  HAL_GPIO_DeInit(USARTx_TX_GPIO_PORT, USARTx_TX_PIN);
 80020e6:	f7fe fb65 	bl	80007b4 <HAL_GPIO_DeInit>
  /* Configure USARTx Rx as alternate function  */
  HAL_GPIO_DeInit(USARTx_RX_GPIO_PORT, USARTx_RX_PIN);
 80020ea:	480b      	ldr	r0, [pc, #44]	; (8002118 <HAL_UART_MspDeInit+0x4c>)
 80020ec:	2180      	movs	r1, #128	; 0x80
 80020ee:	f7fe fb61 	bl	80007b4 <HAL_GPIO_DeInit>

  /*##-3- Disable the DMA #####################################################*/
  /* De-Initialize the DMA channel associated to reception process */
  if(huart->hdmarx != 0)
 80020f2:	6b60      	ldr	r0, [r4, #52]	; 0x34
 80020f4:	b108      	cbz	r0, 80020fa <HAL_UART_MspDeInit+0x2e>
  {
    HAL_DMA_DeInit(huart->hdmarx);
 80020f6:	f7fe f9c7 	bl	8000488 <HAL_DMA_DeInit>
  }
  /* De-Initialize the DMA channel associated to transmission process */
  if(huart->hdmatx != 0)
 80020fa:	6b20      	ldr	r0, [r4, #48]	; 0x30
 80020fc:	b108      	cbz	r0, 8002102 <HAL_UART_MspDeInit+0x36>
  {
    HAL_DMA_DeInit(huart->hdmatx);
 80020fe:	f7fe f9c3 	bl	8000488 <HAL_DMA_DeInit>
  }

  /*##-4- Disable the NVIC for DMA ###########################################*/
  HAL_NVIC_DisableIRQ(USARTx_DMA_TX_IRQn);
 8002102:	200e      	movs	r0, #14
 8002104:	f7fe f954 	bl	80003b0 <HAL_NVIC_DisableIRQ>
  HAL_NVIC_DisableIRQ(USARTx_DMA_RX_IRQn);
}
 8002108:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_DMA_DeInit(huart->hdmatx);
  }

  /*##-4- Disable the NVIC for DMA ###########################################*/
  HAL_NVIC_DisableIRQ(USARTx_DMA_TX_IRQn);
  HAL_NVIC_DisableIRQ(USARTx_DMA_RX_IRQn);
 800210c:	200f      	movs	r0, #15
 800210e:	f7fe b94f 	b.w	80003b0 <HAL_NVIC_DisableIRQ>
 8002112:	bf00      	nop
 8002114:	40023800 	.word	0x40023800
 8002118:	40020400 	.word	0x40020400

0800211c <NMI_Handler>:
 800211c:	4770      	bx	lr

0800211e <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 800211e:	e7fe      	b.n	800211e <HardFault_Handler>

08002120 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8002120:	e7fe      	b.n	8002120 <MemManage_Handler>

08002122 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 8002122:	e7fe      	b.n	8002122 <BusFault_Handler>

08002124 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8002124:	e7fe      	b.n	8002124 <UsageFault_Handler>

08002126 <SVC_Handler>:
 8002126:	4770      	bx	lr

08002128 <DebugMon_Handler>:
 8002128:	4770      	bx	lr

0800212a <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
 800212a:	4770      	bx	lr

0800212c <SysTick_Handler>:
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
  HAL_IncTick();
 800212c:	f7fe b8e0 	b.w	80002f0 <HAL_IncTick>

08002130 <DMA1_Channel1_IRQHandler>:
* @param  None
* @retval None
*/
void TIMx_DMA_IRQHandler(void)
{
  HAL_DMA_IRQHandler(TimHandle.hdma[TIM_DMA_ID_CC3]);
 8002130:	4b01      	ldr	r3, [pc, #4]	; (8002138 <DMA1_Channel1_IRQHandler+0x8>)
 8002132:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8002134:	f7fe ba20 	b.w	8000578 <HAL_DMA_IRQHandler>
 8002138:	200006a8 	.word	0x200006a8

0800213c <DMA1_Channel5_IRQHandler>:
}

void USARTx_DMA_RX_IRQHandler(void)
{
  HAL_DMA_IRQHandler(UartHandle.hdmarx);
 800213c:	4b01      	ldr	r3, [pc, #4]	; (8002144 <DMA1_Channel5_IRQHandler+0x8>)
 800213e:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8002140:	f7fe ba1a 	b.w	8000578 <HAL_DMA_IRQHandler>
 8002144:	20000564 	.word	0x20000564

08002148 <DMA1_Channel4_IRQHandler>:
  * @Note   This function is redefined in "main.h" and related to DMA
  *         used for USART data reception
  */
void USARTx_DMA_TX_IRQHandler(void)
{
  HAL_DMA_IRQHandler(UartHandle.hdmatx);
 8002148:	4b01      	ldr	r3, [pc, #4]	; (8002150 <DMA1_Channel4_IRQHandler+0x8>)
 800214a:	6b18      	ldr	r0, [r3, #48]	; 0x30
 800214c:	f7fe ba14 	b.w	8000578 <HAL_DMA_IRQHandler>
 8002150:	20000564 	.word	0x20000564

08002154 <USART1_IRQHandler>:
  * @Note   This function is redefined in "main.h" and related to DMA
  *         used for USART data transmission
  */
void USARTx_IRQHandler(void)
{
  HAL_UART_IRQHandler(&UartHandle);
 8002154:	4801      	ldr	r0, [pc, #4]	; (800215c <USART1_IRQHandler+0x8>)
 8002156:	f7ff bc78 	b.w	8001a4a <HAL_UART_IRQHandler>
 800215a:	bf00      	nop
 800215c:	20000564 	.word	0x20000564

08002160 <EXTI15_10_IRQHandler>:
  * @param  None
  * @retval None
  */
void EXTI15_10_IRQHandler(void)
{
  HAL_GPIO_EXTI_IRQHandler(USER_BUTTON_PIN);
 8002160:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8002164:	f7fe bbbe 	b.w	80008e4 <HAL_GPIO_EXTI_IRQHandler>

08002168 <__libc_init_array>:
 8002168:	4b0e      	ldr	r3, [pc, #56]	; (80021a4 <__libc_init_array+0x3c>)
 800216a:	b570      	push	{r4, r5, r6, lr}
 800216c:	461e      	mov	r6, r3
 800216e:	4c0e      	ldr	r4, [pc, #56]	; (80021a8 <__libc_init_array+0x40>)
 8002170:	2500      	movs	r5, #0
 8002172:	1ae4      	subs	r4, r4, r3
 8002174:	10a4      	asrs	r4, r4, #2
 8002176:	42a5      	cmp	r5, r4
 8002178:	d004      	beq.n	8002184 <__libc_init_array+0x1c>
 800217a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800217e:	4798      	blx	r3
 8002180:	3501      	adds	r5, #1
 8002182:	e7f8      	b.n	8002176 <__libc_init_array+0xe>
 8002184:	f000 f832 	bl	80021ec <_init>
 8002188:	4b08      	ldr	r3, [pc, #32]	; (80021ac <__libc_init_array+0x44>)
 800218a:	4c09      	ldr	r4, [pc, #36]	; (80021b0 <__libc_init_array+0x48>)
 800218c:	461e      	mov	r6, r3
 800218e:	1ae4      	subs	r4, r4, r3
 8002190:	10a4      	asrs	r4, r4, #2
 8002192:	2500      	movs	r5, #0
 8002194:	42a5      	cmp	r5, r4
 8002196:	d004      	beq.n	80021a2 <__libc_init_array+0x3a>
 8002198:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800219c:	4798      	blx	r3
 800219e:	3501      	adds	r5, #1
 80021a0:	e7f8      	b.n	8002194 <__libc_init_array+0x2c>
 80021a2:	bd70      	pop	{r4, r5, r6, pc}
 80021a4:	08002228 	.word	0x08002228
 80021a8:	08002228 	.word	0x08002228
 80021ac:	08002228 	.word	0x08002228
 80021b0:	0800222c 	.word	0x0800222c

080021b4 <memset>:
 80021b4:	4603      	mov	r3, r0
 80021b6:	4402      	add	r2, r0
 80021b8:	4293      	cmp	r3, r2
 80021ba:	d002      	beq.n	80021c2 <memset+0xe>
 80021bc:	f803 1b01 	strb.w	r1, [r3], #1
 80021c0:	e7fa      	b.n	80021b8 <memset+0x4>
 80021c2:	4770      	bx	lr

080021c4 <strncpy>:
 80021c4:	4603      	mov	r3, r0
 80021c6:	b510      	push	{r4, lr}
 80021c8:	b142      	cbz	r2, 80021dc <strncpy+0x18>
 80021ca:	f811 4b01 	ldrb.w	r4, [r1], #1
 80021ce:	3a01      	subs	r2, #1
 80021d0:	f803 4b01 	strb.w	r4, [r3], #1
 80021d4:	2c00      	cmp	r4, #0
 80021d6:	d1f7      	bne.n	80021c8 <strncpy+0x4>
 80021d8:	441a      	add	r2, r3
 80021da:	e000      	b.n	80021de <strncpy+0x1a>
 80021dc:	bd10      	pop	{r4, pc}
 80021de:	4293      	cmp	r3, r2
 80021e0:	d002      	beq.n	80021e8 <strncpy+0x24>
 80021e2:	f803 4b01 	strb.w	r4, [r3], #1
 80021e6:	e7fa      	b.n	80021de <strncpy+0x1a>
 80021e8:	bd10      	pop	{r4, pc}
	...

080021ec <_init>:
 80021ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80021ee:	bf00      	nop
 80021f0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80021f2:	bc08      	pop	{r3}
 80021f4:	469e      	mov	lr, r3
 80021f6:	4770      	bx	lr

080021f8 <_fini>:
 80021f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80021fa:	bf00      	nop
 80021fc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80021fe:	bc08      	pop	{r3}
 8002200:	469e      	mov	lr, r3
 8002202:	4770      	bx	lr
